<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>(五) C++开发者都应该使用的10个C++11特性 — move</title>

    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.cn/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.cn/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.cn">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.cn/wu-ckai-fa-zhe-du-ying-gai-shi-yong-de-10ge-c11te-xing-move.html" rel="bookmark"
        title="Permalink to (五) C++开发者都应该使用的10个C++11特性 — move">(五) C++开发者都应该使用的10个C++11特性 — move</a></h3>
    </header>

<h6 class="subheader" title="2015-03-28T09:17:00+08:00">Sat 28 March 2015
</h6>


    <p>在说 move 之前有必要重新再认识下 C++ 98/03 中的 lvalues 和 rvalues, 即左值和右值.</p>
<p><strong>首先
对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值;
这是错误的, 我们应该时刻谨记 lvalue 和 rvalue 都是针对表达式而言.</strong>
lvalue 是指那些单一表达式结束之后依然存在的持久对象. 例如: obj, *ptr, prt[index], ++x 等;
rvalue 是指那些表达式结束时就不复存在的临时对象. 例如: 常数 1729, x + y, x++ 等.</p>
<p>当我们写 int x = 10; 时, x 是一个 lvalue, 因为当这个表达式结束时, x 依然存在, 它代表的是一个持久对象.
当我们写 int i = x + y; 时, x + y 是一个 rvalue, 因为当执行这句表达式时, 其实这里应该是:</p>
<div class="highlight"><pre><span></span>&lt;span style=&quot;color: #0000ff&quot;&gt;int&lt;/span&gt; temp = x +&lt;span style=&quot;color: #000000&quot;&gt; y;
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;int&lt;/span&gt; i = temp;
</pre></div>


<p>而这句表达式结束时, temp 就被释放掉了..</p>
<p><strong>再解释下 ++x 和 x++ 的区别.</strong>
++x 是一个 lvalue, 因为它将直接修改 x 的值, 并返回原来的 x, 它代表的还是原来那个持久对象.
而 x++ 却是一个 rvalue, 因为执行这句表达式时, 它其实是下面这样的:</p>
<div class="highlight"><pre><span></span>&lt;span style=&quot;color: #0000ff&quot;&gt;int&lt;/span&gt; temp =&lt;span style=&quot;color: #000000&quot;&gt; x;
x &lt;/span&gt;= x + &lt;span style=&quot;color: #800080&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;return&lt;/span&gt; temp;
</pre></div>


<p>也就是说, 它先拷贝一份持久对象的初值, 再修改持久对象的值, 最后返回刚才拷贝的临时对象.</p>
<p>所以说, <strong>lvalue 与 rvalue 之分的关键就在于表达式代表了什么(是持久对象还是临时对象).
</strong>例如 ++x 代表的是那个持久对象本身, 而 x++ 代表的是那个拷贝的临时对象.</p>
<p>另一个判断一个表达式是不是 lvalue 的方法是看能不能对它取址, 如果可以, 那就是一个 lvalue, 反之就是一个 rvalue.
C++ 中规定, 取址操作要求它的操作数必须是一个 lvalue.
这是因为对一个持久对象取址是 OK 的, 但是对一个临时对象取址是极端危险的, 因为临时对象很快就会被销毁.</p>
<p>对于一个函数来说, <strong>当且仅当它的返回值是一个引用的时候, 它才是 lvalue.</strong>
例如, 给定语句 vector<int> v, v[n] 是一个 lvalue, 因为 <a href=""></a> 返回的是一个引用, 这里是 int&amp;, 用上面的取址判断也是OK的, &amp;v[n] 完全没有问题.
而给定语句 string s、string t, s + t 是一个 rvalue, 因为 +() 返回的是一个新的string(参考前面的 x + y), 并且 &amp;(s + t) 也是非法的.</p>
<p><strong>常量引用与</strong>非<strong>常量引用
</strong>lvalue 和 rvalue 都有常量和非常量之分., 看下面的例子:</p>
<div class="highlight"><pre><span></span>&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; one(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;); &lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; 非常量左值&lt;/span&gt;

&lt;span style=&quot;color: #0000ff&quot;&gt;const&lt;/span&gt; &lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; two(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;); &lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; 常量左值&lt;/span&gt;

&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; three() { &lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; 非常量右值&lt;/span&gt;
    &lt;span style=&quot;color: #0000ff&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;
}

&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;const&lt;/span&gt; &lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; four() { &lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; 常量右值&lt;/span&gt;
    &lt;span style=&quot;color: #0000ff&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;
}&lt;/span&gt;
</pre></div>


<p>一个引用 Type&amp; 可以绑定到非常量 lvalue(可以通过引用来读取和修改原来的值);
但不能绑定到 const lvalue, 因为那将违背 const 的正确性;
也不能绑定到非常量 rvalue, 因为 rvalue 是一个临时对象, 当你通过引用来修改它的值的时候, 而临时对象早就已经不存在了, 结果可想.
更不能绑定到 const rvalue, 因为那将同时违背上面的两点…</p>
<p>而一个常量引用 const Type&amp; 却可以同时绑定到 非常量 lvalue、const lvalue、非常量 rvalue 和 const rvalue. 因为 const Type&amp; “只能看, 不能改..”.</p>
<p>这个时候, 可能会出现疑问<strong>”既然 rvalue 本身就是不能被修改的, 那 const rvalue 和 非常量 rvalue 又有什么不同呢?”</strong>
区别在于, 在 C++ 98/03 中, 非常量 rvalue 可以手动调用 non_const 成员函数来修改值; 在 C++11 中, 答案有了显著的变化, 它能用来实现 move 语意..</p>
<p>OK, 那什么是 mvoe 语义? 简单的说就是, <strong>move 语义允许修改右值.</strong></p>
<p>C++11加入了<strong>右值引用</strong>(rvalue reference)的概念(<strong>用 &amp;&amp; 标识</strong>), 它被来区分对左值或右值的引用.</p>
<p>C++98/03 性能上被长期诟病的问题之一, 就是其耗时且不必要的深拷贝.
例如, 如果创建了或是从函数返回了一个 string 类型的临时对象, 要将其保存起来只能通过生成新的 string 对象并且把原临时对象所有的数据复制进去, 该临时对象和其拥有的內存会被销毁.(为方便理解, 这里忽略了编译器的返回值优化).
什么意思呢? 假设你有一大堆 string 像这样的：</p>
<div class="highlight"><pre><span></span>&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; s0(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; s1(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; s2(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; s3(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; s4(&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; 然后你想像这样把它们串接起来：&lt;/span&gt;
&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt; dest = s0 + &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; + s1 + &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; + s2 + &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; + s3 + &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; &lt;span style=&quot;color: #800000&quot;&gt;&quot;&lt;/span&gt; + s4;
</pre></div>


<p>我们已经知道 +() 会返回一个临时的对象, 所以上面的串接动作就因此产生了 8 个临时对象. 不管怎么说, 这都是很浪费性能的一件事.</p>
<p>在 C++11中, std::sting 新添了"移动构造函数", 对某个 string 的<strong>右值引用可以单纯地从右值复制其内部数据的指针</strong>到新的 string 中，然后将右值中的指针置空.
因为这个临时对象不会再被使用, 没代码会再访问这个空指针, 而且因为这个临时对象的内部指针是NULL, 所以当这个临时对象离开作用域时它的内存也不会被释放掉.
所以, 这个操作不仅没有代价高昂的深拷贝, 还是安全的,对用户不可见的!
这个操作不需要内存的复制, 而且空的临时对象的析构也不会销毁内存, 返回临时对象的函数只需要返回 std::string&amp;&amp; 就可以了. 如果 string 没有 move 构造函数, 那么就会调用常规拷贝构造函数, 如果有, 那么就会优先调用 move 构造函数, 这能够避免大量的内存分配和内存拷贝操作.</p>
<p>返回值类型为 std::string 的函数返回了一个 std::string 类型的临时对象, 这样的临时对象会被自动当作右值引用, 而不需要显示地将返回值类型改为 std::string&amp;&amp;.</p>
<p>对于 stl 中常用数据结构, C++11 已经默认加了 move 构造函数 和 重载了 = 运算符, 但是如果要给我我们自己写的类添加 move 语义已经怎么做呢?
答案是配合模板函数 <strong>std::move<T>()</strong> , 这个函数将一个数值强制转化为右值, 具体做法如下:</p>
<div class="highlight"><pre><span></span>template &lt;typename T&gt;
&lt;span style=&quot;color: #0000ff&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt; Buffer {
   std::&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;string&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;          _name;
   size_t               _size;
   std::unique_ptr&lt;/span&gt;&lt;T[]&gt;&lt;span style=&quot;color: #000000&quot;&gt; _buffer;

&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;:
   &lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; move constructor&lt;/span&gt;
   Buffer(Buffer&amp;&amp;&lt;span style=&quot;color: #000000&quot;&gt; temp):
      &lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; temp._name 本身是 lvalue, 使用 std::move 后转化为 右值, 所以这里将触发 std::string 的 move 构造函数.&lt;/span&gt;
&lt;span style=&quot;color: #000000&quot;&gt;      _name(std::move(temp._name)),
      _size(temp._size),
      _buffer(std::move(temp._buffer)) {
      temp._buffer &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; nullptr;
      temp._size &lt;/span&gt;= &lt;span style=&quot;color: #800080&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;;
   }

   &lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; move assignment operator&lt;/span&gt;
   Buffer&amp; &lt;span style=&quot;color: #0000ff&quot;&gt;operator&lt;/span&gt;=(Buffer&amp;&amp;&lt;span style=&quot;color: #000000&quot;&gt; temp) {
      assert(&lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;this&lt;/span&gt; != &amp;temp); &lt;span style=&quot;color: #008000&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000&quot;&gt; assert if this is not a temporary&lt;/span&gt;
&lt;span style=&quot;color: #000000&quot;&gt;
      _buffer &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; nullptr;
      _size &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; temp._size;
      _buffer &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; std::move(temp._buffer);

      _name &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; std::move(temp._name);

      temp._buffer &lt;/span&gt;=&lt;span style=&quot;color: #000000&quot;&gt; nullptr;
      temp._size &lt;/span&gt;= &lt;span style=&quot;color: #800080&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;;

      &lt;/span&gt;&lt;span style=&quot;color: #0000ff&quot;&gt;return&lt;/span&gt; *&lt;span style=&quot;color: #0000ff&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000&quot;&gt;;
   }
};&lt;/span&gt;
</pre></div>


<p> t </p>
<p class="subheader">Category: <a href="http://blog.smallcpp.cn/category/c11.html">C++11</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="wu-ckai-fa-zhe-du-ying-gai-shi-yong-de-10ge-c11te-xing-move" data-title="(五) C++开发者都应该使用的10个C++11特性 — move" data-url="http://blog.smallcpp.cn/wu-ckai-fa-zhe-du-ying-gai-shi-yong-de-10ge-c11te-xing-move.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.cn/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/category/c11.html">C++11</a></li>
            <li><a href="http://blog.smallcpp.cn/category/cocos2d.html">Cocos2d</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju-java-ru-men-dao-jing-tong.html">大数据 Java 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju-linux-ru-men-dao-jing-tong.html">大数据 Linux 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju-mongodb-ru-men-dao-jing-tong.html">大数据 Mongodb 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju-redis-ru-men-dao-jing-tong.html">大数据 Redis 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.cn/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.cn/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.cn/category/java.html">JAVA</a></li>
            <li><a href="http://blog.smallcpp.cn/category/lua.html">Lua</a></li>
            <li><a href="http://blog.smallcpp.cn/category/pyqt.html">PyQt</a></li>
            <li><a href="http://blog.smallcpp.cn/category/python.html">Python</a></li>
            <li><a href="http://blog.smallcpp.cn/category/qt.html">QT</a></li>
            <li><a href="http://blog.smallcpp.cn/category/ruan-jian-she-ji.html">软件设计</a></li>
            <li><a href="http://blog.smallcpp.cn/category/za-xiang.html">杂项</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>