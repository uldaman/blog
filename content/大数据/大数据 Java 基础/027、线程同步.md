Title: 027、线程同步(Thinking in Java)
Author: Martin
Date: 2016-03-17 10:55
Summary: 线程同步(Thinking in Java), 线程安全问题和线程同步的概念不多描述了, 主要看看 Java 中的解决方案.

同步
synchronized 同步代码块, 线程间的锁
获取锁的线程执行完退出了, 或者异常了, 锁才会被释放
那么问题就是, 当锁被占用时,  其它线程就只能一直 wait, 好在 java 提供了 lock 对象, 它支持 timeout
另外, synchronized 不支持读写锁分离, 而 lock 支持
lock 的锁需要显示地手动获取释放

java.util.concurrent.locks.Lock
Lock 是个接口, 提供以下方法:
lock
lockInterruptibly 可调用 interrupt 中断等待
tryLock 尝试获取锁

ReentrantLock 可重入锁, 是 JDK 中唯一实现了 Lock 接口的类, 并且提供了更多的方法

ReadWriteLock 也是一个接口, 提供两个方法
readLock
writeLock

ReentrantReadWriteLock 是 JDK 唯一实现了 ReadWriteLock 的类, 它提供了更多的方法, 当然主要还是 readLock 和 writeLock 两个方法.


[TOC]

线程安全问题和线程同步的概念不多描述了, 主要看看 Java 中的解决方案.

## 1. synchronized 关键字
__synchronized__ 关键字可用来给对象的方法或者代码块加锁, 当它锁定一个方法或者一个代码块的时候, 同一时刻最多只有一个线程执行这段代码, 当两个并发线程访问同一个对象 object 中的这个加锁同步代码块时, 一个时间内只能有一个线程得到执行, 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块.

通常设计中, 要控制对共享资源的访问, 得先把它包装进一个对象, 然后把所有要访问这个资源的方法标记为 __synchronized__.

所有对象都自动含有单一的锁(也称__监视器__), 当在对象上调用其任意 synchronized 方法时, 该对象都会被自动加锁, 这时, 该对象上的其他 synchronized 方法只有等到前一个方法调用完毕并释放锁之后才能被调用.

## 2. Lock 对象
Java SE5 的 __java.util.concurrent__ 类库还包含有定义在 __java.util.concurrent.locks__ 中的显式的互斥机制.

```java
import java.util.concurrent.locks.*;

class MutexEvent {
    private Lock lock = new ReentrantLock();

    public void fun() {
        lock.lock();
        try {
            // ...
            return;
        } finally {
            lock.unlock();
        }
    }
}
```

