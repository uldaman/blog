Title: 033、IO 基础
Author: Martin
Date: 2016-03-22 18:50
Summary: 简单的介绍 Java IO 基础, 相关的类都在 java.io 包中.

[TOC]

# File 类概述和构造方法
- A: File 类的概述
    - File 更应该叫做一个路径
        - 文件路径或者文件夹路径
        - 路径可以是绝对路径或者相对路径
    - File 对象是文件和目录的抽象表示形式
- B: 构造方法
    - File(String pathname): 根据一个路径得到File对象
    - File(String parent, String child): 根据一个目录和一个子文件/目录得到 File 对象
    - File(File parent, String child): 根据一个父File对象和一个子文件/目录得到 File 对象

## 操作 File 类
### File 类创建功能
- A: 创建功能
    - public boolean createNewFile(): 创建文件 如果存在这样的文件, 就不创建了
    - public boolean mkdir(): 创建文件夹 如果存在这样的文件夹, 就不创建了
    - public boolean mkdirs(): 创建文件夹,如果父文件夹不存在, 会帮你创建出来

### File 类重命名和删除功能
- A: 重命名和删除功能
    - public boolean renameTo(File dest): 把文件重命名为指定的文件路径, 还可以当剪切功能使用
    - public boolean delete(): 删除文件或者文件夹
- B: 重命名注意事项
    - 如果路径名相同, 就是改名
    - 如果路径名不同, 就是改名并剪切
- C: 删除注意事项:
    - Java 中的删除不走回收站
    - 要删除一个文件夹, 请注意该文件夹内不能包含文件或者文件夹

### File 类判断功能
- A: 判断功能
    - public boolean isDirectory(): 判断是否是目录
    - public boolean isFile(): 判断是否是文件
    - public boolean exists(): 判断是否存在
    - public boolean canRead(): 判断是否可读
        - setReadable(false) 对 windows 无效, windows 认为一切资源可读(这里说的读写是指 io 流)
    - public boolean canWrite(): 判断是否可写
        - setWritable(false) 对 windows 有效
    - public boolean isHidden(): 判断是否隐藏

### File 类获取功能
- A: 获取功能
    - public String getAbsolutePath(): 获取绝对路径
    - public String getPath(): 获取构造函数中传入的路径
    - public String getName(): 获取名称
    - public long length(): 获取长(字节数)
    - public long lastModified(): 获取最后一次的修改时间(毫秒值)
    - public String[] list(): 获取指定目录下的所有文件或者文件夹的名称数组
    - public File[] listFiles(): 获取指定目录下的所有文件或者文件夹的 File 数组

### File 过滤器
- A: 文件名称过滤器的概述
    - public String[] list(FilenameFilter filter)
    - public File[] listFiles(FileFilter filter)
- B: 文件名称过滤器的使用
    - 需求: 判断E盘目录下是否有后缀名为 .jpg 的文件, 如果有, 就输出该文件名称
- C: 源码分析
    - 带文件名称过滤器的 list() 方法的源码

# IO 流概述及其分类
- 概念
    + IO 流用来处理设备之间的数据传输
    + Java 对数据的操作是通过__流__的方式
    + Java 用于操作流的类都在 __IO 包__中
    + 流按流向分为两种
        * 输入流
        * 输出流
    + 流按操作类型分为两种:
        * 字节流
            - 字节流可以操作任何数据,因为在计算机中任何数据都是以__字节__的形式存储的
        * 字符流
            - 字符流只能操作__纯字符__数据, 比较方便
- IO 流常用__抽象__父类
    + 字节流的__抽象__父类:
        * InputStream
        * OutputStream
    + 字符流的__抽象__父类:
        * Reader
        * Writer
- IO 程序书写
    + 使用前, 导入 IO 包中的类
    + 使用时, 进行 IO 异常处理
    + 使用后, 释放资源

## 字节流
### FileInputStream
```java
java.lang.Object
    java.io.InputStream
        java.io.FileInputStream
```
#### read()
功能: 一次读取一个字节, 返回读到的字节, 如果返回 -1 表示文件结束

```java
FileInputStream fis = new FileInputStream("aaa.txt");   // 创建一个文件输入流对象, 并关联 aaa.txt
int b;                                                  // 定义变量, 记录每次读到的字节
while ((b = fis.read()) != -1) {                         // 将每次读到的字节赋值给 b 并判断是否是 -1
    System.out.println(b);                              // 打印每一个字节
}

fis.close();                                            // 关闭流释放资源
```

read() 即然是读取字节, 那它的方法返回值为什么是int?

因为字节输入流可以操作任意类型的文件, 比如图片音频等, 这些文件底层都是以二进制形式的存储的, 如果每次读取都返回 byte, 有可能在读到中间的时候遇到 111111111, 那么这 11111111 是 byte 类型的 -1, 我们的程序是遇到 -1 就会停止不读了, 后面的数据就读不到了, 所以在读取的时候用 int 类型接收, 如果 11111111 会在其前面补上 24 个 0 凑足 4 个字节, 那么 byte 类型的 -1 就变成 int 类型的 255 了, 这样可以保证整个数据读完, 而结束标记的 -1 就是 int 类型

### FileOutputStream
```java
java.lang.Object
    java.io.OutputStream
        java.io.FileOutputStream
```

#### write()
功能: 一次写入一个字节

```java
FileOutputStream fos = new FileOutputStream("bbb.txt"); // 如果没有 bbb.txt, 会创建出一个
//fos.write(97); //虽然写出的是一个 int 数, 但是在写出的时候会将前面的 24 个 0 去掉,所以写入的一个 byte
fos.write(98);
fos.write(99);
fos.close();
```

#### 追加
以追加的方式写入文件

```java
FileOutputStream fos = new FileOutputStream("bbb.txt", true); // 第二个参数传 true 就是以追加的方式写入文件
fos.write(98);
fos.write(99);
fos.close();
```

### 文件的拷贝
#### 简单粗暴的拷贝
```java
FileInputStream fis = new FileInputStream("致青春.mp3");
FileOutputStream fos = new FileOutputStream("copy.mp3");

int b;
while ((b = fis.read()) != -1) {
    fos.write(b);
}

fis.close();
fos.close();
```

#### 改良版
上面的版本虽然实现了拷贝功能, 然后效率十分低下, 因为它是读一个字节写一个字节, 相当于执行了 _(len(致青春.mp3) * 2)_ 次 IO 操作, 那可不可以一次性把源文件读完, 再去写呢? 也是可以的.

- available(): 获取 FileInputStream 对象的字节大小

```java
FileInputStream fis = new FileInputStream("致青春.mp3");
FileOutputStream fos = new FileOutputStream("copy.mp3");

byte[] arr = new byte[fis.available()];                 // 根据文件大小做一个字节数组
fis.read(arr);                                          // 将文件上的所有字节读取到数组中
fos.write(arr);                                         // 将数组中的所有字节一次写到了文件上

fis.close();
fos.close();
```

#### 再次改良
Java 程序是运行在 JVM 上的, 如果使用上面改良版的拷贝功能, 那么就会存在这样的一个问题:<br>
待拷贝文件非常大时(如 十几二十几个 G 的), 那更本不可能申请那么大的数组...

解决方法是使用小数组多次拷贝.

要实现这个功能, 首先要知道两个知识点:

- read(byte[] b) 读到的字节放在 b 里面, 返回值是读取到的有效字节个数, -1 表示文件结束
- write(byte[] b, int off, int len)
    + Writes len bytes from the specified byte array starting at offset off to this file output stream.

```java
FileInputStream fis = new FileInputStream("致青春.mp3");
FileOutputStream fos = new FileOutputStream("copy.mp3");
int len;
byte[] arr = new byte[1024 * 8];                    // 自定义字节数组

while ((len = fis.read(arr)) != -1) {
    fos.write(arr, 0, len);                         // 写出字节数组写出有效个字节个数
}

fis.close();
fos.close();
```

我们来分析下这段代码, 为什么需要使用 __write(byte[] b, int off, int len)__ 这种 write?<br>
假设下, 如果待读文件里面有 3 个字节(abc), 我们申请一个 2 字节的数组, 每次从待读文件里读 2 个字节出来, 那么第一次读出来的是 [ab], 然后写入文件, 第二次读的出来的是 [cb], 为什么会是 [cb] 呢?<br> 因为我们的待读文件里只剩下一个 c 了, 所以只重写了数组第一位, 那这样最后写入文件的就是 [abcb], 明显是不对的, 所以使用 __write(byte[] b, int off, int len)__, 写入的时候只写入我们刚才读出来的__有效__字节.

#### Java 自带的缓冲区式拷贝
- 缓冲思想
    + 从上面的几次加强上已经看到:
        * 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多
        * java 本身在设计的时候也考虑到了这样的设计思想, 所以提供了字节缓冲区流
- __BufferedInputStream__
    + BufferedInputStream 内置了一个缓冲区(数组)
    + 从 BufferedInputStream 中读取一个字节时
        * BufferedInputStream 会一次性从文件中读取 8192 个, 先存放在缓冲区中
        * 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取
        * 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个
- __BufferedOutputStream__
    + BufferedOutputStream 也内置了一个缓冲区(数组)
    + 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中
    + 直到缓冲区写满, BufferedOutputStream 才会把缓冲区中的数据一次性写到文件里

```java
java.lang.Object
    java.io.InputStream
        java.io.FilterInputStream
            java.io.BufferedInputStream


java.lang.Object
    java.io.OutputStream
        java.io.FilterOutputStream
            java.io.BufferedOutputStream
```
<br>

```java
FileInputStream fis = new FileInputStream("致青春.mp3");        // 创建文件输入流对象,关联致青春.mp3
FileOutputStream fos = new FileOutputStream("copy.mp3");        // 创建输出流对象,关联 copy.mp3

BufferedInputStream bis = new BufferedInputStream(fis);         // 创建缓冲区对 fis 装饰
BufferedOutputStream bos = new BufferedOutputStream(fos);       // 创建缓冲区对 fos 装饰

int b;
while ((b = bis.read()) != -1) {
    bos.write(b);
}

bis.close();                        // 只关装饰后的对象即可
bos.close();
```

#### 自改良和 Buffered 哪个更效率
定义小数组如果是 8192 个字节大小和 Buffered 比较的话, 定义小数组会略胜一筹, 因为读和写操作的是同一个数组, 而 Buffered 操作的是两个数组.

### flush 和 close
首先, 先弄明白 BufferedOutputStream 的 IO 流程, 当我们通过 BufferedOutputStream 去写文件时, Java 先向 BufferedOutputStream 的缓冲区中写, 当写满 8192 个字节后, java 才会把缓冲区的内容刷新到硬盘中.

那么问题来了, 谁也不能保证一个文件正好是 8192 倍数, 那当缓冲区不足 8192 个字节时, 怎么通知 java 去把缓冲区的内容刷新到硬盘中呢? 有两种方法:

- flush()
    + 用来刷新缓冲区的, 刷新后还可以接着使用 BufferedOutputStream
- close()
    + 关闭流, 但在关闭流之前会刷新缓冲区, 关闭后不能再使用 BufferedOutputStream

### 读写中文
- 字节流读取中文的问题
    + 字节流在读中文的时候有可能会读到半个中文,造成乱码
-  字节流写出中文的问题
    + 字节流直接操作的字节, 所以写出中文必须将字符串转换成字节数组
    + 写出回车换行 write("\r\n".getBytes());

总之, 用字节流来读写中文还是有不少问题的...所以当遇到中文时, 一般使用 **字符流** 来读写, 这个后面再讲.

### 异常处理
#### java 1.6 及以前的版本
```java
FileInputStream fis = null;
FileOutputStream fos = null;
try {
    fis = new FileInputStream("aaa.txt");
    fos = new FileOutputStream("bbb.txt");
    int b;
    while ((b = fis.read()) != -1) {
        fos.write(b);
    }
} finally {
    try {
        if (fis != null) {
            fis.close();
        }
    } finally { // 能关一下尽量关一个
        if (fos != null) {
            fos.close();
        }
    }
}
```

#### java 1.7 及以上的版本
```java
try (
    FileInputStream fis = new FileInputStream("aaa.txt");
    FileOutputStream fos = new FileOutputStream("bbb.txt");
) {
    int b;
    while ((b = fis.read()) != -1) {
        fos.write(b);
    }
}
```
<br>
上面的代码, try 后面 {} 里的代码执行完后, 就会自动调用流对象的 close() 方法将流关掉 (类似 python 中的 with 语法).

这是 1.7+ 的异常处理新特性, 在 try() 中创建的对象如果实现了 **AutoCloseable** 这个接口中的 close() 方法(也必须实现, 否则在 try() 中使用会直接报错), 当发生异常或者执行完 {} 里的语句后, 会自动调用我们实现的 close() 方法.<br>
InputStream 及 OutputStream 都已经实现好了.

## 字符流
字符流专门用来操作文本, 常用的就是 `FileReader` 与 `FileWriter`.

```java
java.lang.Object
    java.io.Reader
        java.io.InputStreamReader
            java.io.FileReader

java.lang.Object
    java.io.Writer
        java.io.OutputStreamWriter
            java.io.FileWriter
```
<br>
写文件:

```java
FileWriter fw = new FileWriter("test.txt"); // 如果没有 test.txt, 会创建出一个
fw.write("text");
fw.close()
```
<br>
读文件:

```java
FileReader fr = new FileReader("text.txt");
int ch = 0;
while((ch = fr.read()) != -1) {
    System.out.println((char)ch);
}
```
<br>
或者用字符数组:

```java
FileReader fr = new FileReader("text.txt");
char[] buf = new char[1024];

int num = 0;
while((num = fr.read(buf)) != -1) {
    System.out.println(new String(buf, 0, num));
}
fr.close();
```
<br>
与字节流相同, 字符流也提供了**缓冲区**的快捷操作类:

```java
java.lang.Object
    java.io.Reader
        java.io.BufferedReader

java.lang.Object
    java.io.Writer
        java.io.BufferedWriter
```
<br>
