JVM

结构


- `Class File`
    + `*.class` 文件
- `Class Loader` 类加载器
- `Runtime Data Area` 运行时数据区
    + `Method Area` 方法区 (线程共享)
        + `*.class` 文件被加载时会在方法区创建该类的描述符
            * 程序将根据方法区的类描述符创建类的实例
        + 类描述符只被创建一次, 当使用完后并不会从方法区移除
    + `Heap`  堆区 (线程共享)
        + 堆内存用来存放由 new 出来的对象, 栈中的变量指向堆内存中的对象地址
            * 堆中保存着对象的属性、方法的引用(方法的主体还是在方法区)
        + 在堆中分配的内存, 由 JVM 的自动垃圾回收器来管理
    + `Java Stack` 栈区
        + 基本类型的变量和引用变量都在栈内存中分配, 当超过变量的作用域后, Java 会自动释放掉为该变量所分配的内存空间
    + `Native Method Statck` 本地方法栈 (=\> 操作系统)
    + `Program Counter Register` 程序计数器
- `Execution Engine` 执行引擎
- `Native Interface` 本地接口
- `Native Libraries` 本地类库

JVisualVM JDK 自带的性能监视工具

监视 Visual GC


补充静态代码块:
    使用 Class.forName("") 加载类时, 如果指定第二个参数为 false, 则不执行静态代码块, 等下次加载时会再执行静态代码块 (只执行静态代码块, 并不会重新加载类, 类只会被加载一次)


Class-Method-Field-反射


java.lang.Class: 类类, 描述类的类, 类描述符
java.lang.reflect.Method: 方法类, 描述方法的类, 方法描述符
java.lang.reflect.Field: 字段类 (属性类), 描述字段的类, 字段描述符
java.lang.reflect.constructors: 构造器类, 描述构造方法的类, 构造方法描述符
java.lang.reflect.modifier: 修饰符类, 描述修饰符的类, 修饰符描述符

class.getDeclareMethods 获取类中声明的方法 (不包含继承的父类方法, 因为没有声明)
class.getMethods 获取类的方法 (包含继承的方法)

反射:
通过类描述符得到指定的方法描述符, 然后通过 method.invoke(object, param) 调用方法;
注意, 反射依然遵守方法权限的规则 (public, private, protect), 但是通过 method.setAccessible(true) 就能 invoke private protect 的方法了.


method.getModifiers 获取方法的修饰符
