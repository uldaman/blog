author: Martin
date: 2015-02-15 14:24
title: '[转]UML 中关系详解以及在visio中的表示'

Uml 关系主要有四大类： 依赖，关联，泛化，实现。

其中 依赖和关联是事物之间语义上的横向关系，泛化和实现是事物之间的纵向关系。

一：依赖 Dependency

图示：- - - - - >

定义：关系最为松散的，单向的，暂时产生关系的事物之间使用。

使用图例：在静态图、组件图、部署图中两事物的弱依赖关系用此图示。

二：关联 Association

图示：此图为visio中画法（在uml静态结构中,拖动复合图例，然后双击此图例，将出现下图，在关联端list中，聚合列都选择无，然后在isNavigable列中选择划箭头的端。然后点选确定，就出现右侧的关联图例）。

![](http://images.cnitblog.com/blog/67859/201305/15112706-8ed59d6fb54044a09ff3df376a612c55.jpg)

定义：两事物之间的比较密切关系。

实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。关联转换为一个实例作用域的变量。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。

使用图例：在静态图中使用，其他图中也有类似的关联关系，但细化为其他关系。

其中具体细分了两种关系：聚合和组合。

1聚合 Aggregation

图示：此图为visio中画法（在uml静态结构中,拖动复合图例，然后双击此图例，将出现下图，在关联端list中，在聚合列中在需划箭头端选择共享选项。然后点选确定，就出现左侧的聚合图例）。

![](http://images.cnitblog.com/blog/67859/201305/15112307-9adbdf2903aa4877b95c4db191351c28.jpg)

定义：整体和个体之间的关系，个体生命周期的消亡对整体生命周期没有太大的影响。has a的关系。

聚合是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成一个实例作用域变量。

关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。

2组合 Composition

图示：此图为visio中画法（在uml静态结构中,直接拖动复合图例）

![](http://images.cnitblog.com/blog/67859/201305/15112511-5fe7f219d8174593b0cf1536dabe4bb6.jpg)

定义：整体和个体之间的关系，contains a 的关系。

组合是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。组合也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。

在visio中 聚合和组合关系被分别称之为共享和复合关系。主要在静态图中使用。菱形为整体一端，另一端为个体。

三：泛化 Generalization

图示：此图为visio中画法（在uml静态结构中,直接拖动归纳图例）

![](http://images.cnitblog.com/blog/67859/201305/15113815-f785230f6f564dd7a16d44a73a875f38.jpg)

定义：特殊到一般的关系。在软件开发中被称为继承关系，is a 的关系。

四：实现 Realization

图示：此图为visio中画法（右击类，然后选择形状显示选项，然后再勾选如左边所示的实现链接，点选确定，此时选择此类例图，将出现黄色菱形，点选黄色菱形，然后划线到要关联的事物中。即出现此虚箭头线）。

![](http://images.cnitblog.com/blog/67859/201305/15114412-795145b15a3d4724ad96d7ead3665749.jpg)

定义：类元之间的实现关系，在软件开发中被称为实现接口，或者抽象类之间的实现关系。

另外在用例图中，存在3种关系

1：参与者与参与者之间泛化关系，即visio中的归纳图例。

2：参与者与用例之间用依赖关系。即visio中的通信图例。

3：用例与用例之间用关联关系，即拖拽visio中的扩展图例。有时也可以用泛化关系。

其中关联分为两类：include关系，extends关系。

1）包含关系：把几个用例的公共步骤分离成一个被包含的用例,用例间的包含关系允许包含提供者用例的行为到客户用例中.把包含用例称为客户用例,被包含用例称为提供者用例.包含用例提供功能给客户用例。通俗一点讲就是把一个复杂的事物，拆分成几部分，整体和部分之间用包含关系。

![](http://images.cnitblog.com/blog/67859/201305/15141256-f18714c58b5b4458ab48eba60ac9fd0a.jpg)

2)扩展关系：是把新行为插入到已有用例中的方法.基础用例提供了一组扩展点.这些扩展点可以添加新的行为.而扩展用例提供了一组插入片段.这些片段能插入到基础用例的扩展点。将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中，做基事件之后，我可能做扩展事件，也可能不做（在特殊情况下需要的新功能，扩展点就是特殊情况）。通俗一点讲就是一个操作，可以有多种选择方式，每种方式都可以实现此功能。多个实现和功能接口之间是一种扩展关系。

![](http://images.cnitblog.com/blog/67859/201305/15142105-41fd459057df4abca87da649b9f29f6c.jpg)

3）泛化关系：用例的泛化关系与类的泛化关系相似,即在用例泛化中,子用例表示父用例的特殊形式,子用例从父用例继承了行为和属性,还可以添加行为和属性,改变已继承的行为。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。

![](http://images.cnitblog.com/blog/67859/201305/15143703-76c9e4fc7d8c4d1d8a7080564d8e3933.jpg)

包含以及扩展过程与泛化过程类似

共性：都是从现有的用例中抽取出公共的那部分信息，作为一个单独的用例，然后通后过不同的方法来重用这个公共的用例，以减少模型维护的工作量

但三者对用例关系的优化侧重点是不同的。如下：
●泛化侧重表示子用例间的互斥性；
●包含侧重表示被包含用例对Actor提供服务的间接性；
●扩展侧重表示扩展用例的触发不定性；详述如下：

既然用例是系统提供服务的UML表述，那么服务这个过程在所有用例场景中是必然发生的，但发生按照发生条件可分为如下两种情况：

⒈无条件发生：肯定发生的；

⒉有条件发生：未必发生，发生与否取决于系统状态；

因此，针对用例的三种关系结合系统状态考虑，泛化与包含用例属于无条件发生的用例，而扩展属于有条件发生的用例。进一步，用例的存在是为Actor提供服 务，但用例提供服务的方式可分为间接和直接两种，依据于此，泛化中的子用例提供的是直接服务，而包含中的被包含用例提供的是间接服务。同样，扩展用例提供的也是直接服务，但扩展用例的发生是有条件的。

另外一点需要提及的是：泛化中的子用例和扩展中的扩展用例均可以作为基本用例事件的备选择流而存在。

备注：默认情况下visio没有include关系，可以通过一下方式来添加,选择工具栏uml,再选择构造型，添加如图所示的一行，点选确定。此后将可以引用此include关系。

![](http://images.cnitblog.com/blog/67859/201305/15134242-7af56e201f554902ae31305c9cde0011.jpg)

拖一个扩展图例，然后双击，如下图，构造型中就多出一个list include,选择include,点选确定。此时右侧扩展图例上的文字将变为include.

![](http://images.cnitblog.com/blog/67859/201305/15134726-c335b9dd41154ca1bb3007c0e7f845d0.jpg)


el<
