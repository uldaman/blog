<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>054、反射之动态代理</title>

    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.com/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.com/054-fan-she-zhi-dong-tai-dai-li.html" rel="bookmark"
        title="Permalink to 054、反射之动态代理">054、反射之动态代理</a></h3>
    </header>

<h6 class="subheader" title="2016-10-11T13:06:00+08:00">Tue 11 October 2016
</h6>


    <div class="toc">
<ul>
<li><a href="#_1">代理模式</a><ul>
<li><a href="#_2">静态代理</a></li>
<li><a href="#_3">动态代理</a></li>
</ul>
</li>
<li><a href="#_4">动态代理实例</a><ul>
<li><a href="#api">相关 API</a><ul>
<li><a href="#1-javalangreflectproxy">1) java.lang.reflect.Proxy</a></li>
<li><a href="#2-javalangreflectinvocationhandler">2) java.lang.reflect.InvocationHandler</a></li>
<li><a href="#3-javalangclassloader">3) java.lang.ClassLoader</a></li>
</ul>
</li>
<li><a href="#_5">实现步骤</a></li>
<li><a href="#_6">示例</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>代理模式</h1>
<p>代理模式是 GOF 的23种设计模式之一 (结构型模式), 通过引入一个新的对象, 来实现对真实对象的操作或者将新的对象作为真实对象的一个替身, 即代理对象. 它可以在客户端和目标对象之间起到中介的作用, 并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务.</p>
<p>根据代理类的生成时间不同可以将代理分为**静态**代理和**动态**代理两种.</p>
<h2 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>静态代理</h2>
<p>由程序员创建或工具生成代理类的源码, 再编译代理类. 所谓静态也就是在程序运行前就已经存在代理类的字节码文件, 代理类和委托类的关系在运行前就确定了.</p>
<p><strong>缺点</strong>:</p>
<ul>
<li>代理对象的一个接口只服务于一种类型的对象, 如果要代理的方法很多, 势必要为每一种方法都进行代理, 静态代理在程序规模稍大时就无法胜任了</li>
<li>如果接口增加一个方法, 除了所有实现类需要实现这个方法外, 所有代理类也需要实现此方法. 增加了代码维护的复杂度</li>
</ul>
<h2 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>动态代理</h2>
<p>动态代理类的源码是在程序运行期间由 JVM 根据反射等机制动态的生成, 所以不存在代理类的字节码文件. 代理类和委托类的关系是在程序运行时确定.</p>
<p><strong>优点</strong>:</p>
<p>动态代理与静态代理相比较, 最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理 (InvocationHandler.invoke). 这样, 在接口方法数量比较多的时候, 我们可以进行灵活处理, 而不需要像静态代理那样每一个方法进行中转.</p>
<p><strong>缺点</strong>:</p>
<p>动态代理解决了代理代理的缺点, 但它始终无法摆脱仅支持 interface 代理的桎梏; 但是我们有更强大的代理 -- <code>cglib</code>, 以后再介绍这个.</p>
<h1 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>动态代理实例</h1>
<h2 id="api"><a name="user-content-api" href="#api" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>相关 API</h2>
<h3 id="1-javalangreflectproxy"><a name="user-content-1-javalangreflectproxy" href="#1-javalangreflectproxy" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>1) <code>java.lang.reflect.Proxy</code></h3>
<p>这是 Java 动态代理机制生成的所有动态代理类的父类, 它提供了一组静态方法来为一组接口动态地生成代理类及其对象.</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span>
<span style="color: #A71D5D">static</span> <span style="color: #333333">InvocationHandler</span> <span style="color: #795DA3">getInvocationHandler</span><span style="color: #A71D7E">(</span><span style="color: #333333">Object</span> <span style="color: #333333">proxy</span><span style="color: #A71D7E">)</span>

<span style="color: #999988; font-style: italic">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span>
<span style="color: #A71D5D">static</span> <span style="color: #333333">Class</span> <span style="color: #795DA3">getProxyClass</span><span style="color: #A71D7E">(</span><span style="color: #333333">ClassLoader</span> <span style="color: #333333">loader</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Class</span><span style="color: #A71D7E">[]</span> <span style="color: #333333">interfaces</span><span style="color: #A71D7E">)</span>

<span style="color: #999988; font-style: italic">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span>
<span style="color: #A71D5D">static</span> <span style="color: #A71D5D; font-weight: bold">boolean</span> <span style="color: #795DA3">isProxyClass</span><span style="color: #A71D7E">(</span><span style="color: #333333">Class</span> <span style="color: #333333">cl</span><span style="color: #A71D7E">)</span>

<span style="color: #999988; font-style: italic">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span>
<span style="color: #A71D5D">static</span> <span style="color: #333333">Object</span> <span style="color: #795DA3">newProxyInstance</span><span style="color: #A71D7E">(</span><span style="color: #333333">ClassLoader</span> <span style="color: #333333">loader</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Class</span><span style="color: #A71D7E">[]</span> <span style="color: #333333">interfaces</span><span style="color: #A71D7E">,</span> <span style="color: #333333">InvocationHandler</span> <span style="color: #333333">h</span><span style="color: #A71D7E">)</span>
</pre></div>

<br></p>
<h3 id="2-javalangreflectinvocationhandler"><a name="user-content-2-javalangreflectinvocationhandler" href="#2-javalangreflectinvocationhandler" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>2) <code>java.lang.reflect.InvocationHandler</code></h3>
<p>这是调用处理器接口, 它自定义了一个 invoke 方法, 用于集中处理在动态代理类对象上的方法调用, 通常在该方法中实现对委托类的代理访问. 每次生成动态代理类对象时都要指定一个对应的调用处理器对象.</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">// 该方法负责集中处理动态代理类上的所有方法调用. 第一个参数既是代理类实例, 第二个参数是被调用的方法对象</span>
<span style="color: #999988; font-style: italic">// 第三个方法是调用参数. 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span>
<span style="color: #333333">Object</span> <span style="color: #795DA3">invoke</span><span style="color: #A71D7E">(</span><span style="color: #333333">Object</span> <span style="color: #333333">proxy</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Method</span> <span style="color: #333333">method</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Object</span><span style="color: #A71D7E">[]</span> <span style="color: #333333">args</span><span style="color: #A71D7E">)</span>
</pre></div>

<br></p>
<h3 id="3-javalangclassloader"><a name="user-content-3-javalangclassloader" href="#3-javalangclassloader" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>3) <code>java.lang.ClassLoader</code></h3>
<p>这是类装载器类, 负责将类的字节码装载到 Java 虚拟机 (JVM) 中并为其定义类对象, 然后该类才能被使用. Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用, 它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 <code>.class</code> 文件中.</p>
<p>每次生成动态代理类对象时都需要指定一个类装载器对象.</p>
<h2 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>实现步骤</h2>
<ul>
<li>实现 InvocationHandler 接口创建自己的调用处理器</li>
<li>给 Proxy 类提供 ClassLoader 和代理接口类型数组创建动态代理类</li>
<li>以调用处理器类型为参数, 利用反射机制得到动态代理类的构造函数</li>
<li>以调用处理器对象为参数, 利用动态代理类的构造函数创建动态代理类对象</li>
</ul>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">// InvocationHandlerImpl 实现了 InvocationHandler 接口, 并能实现方法调用从代理类到委托类的分派转发</span>
<span style="color: #999988; font-style: italic">// 其内部通常包含指向委托类实例的引用, 用于真正执行分派转发过来的方法调用</span>
<span style="color: #333333">InvocationHandler</span> <span style="color: #333333">handler</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">InvocationHandlerImpl</span><span style="color: #A71D7E">(..);</span>

<span style="color: #999988; font-style: italic">// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象</span>
<span style="color: #333333">Class</span> <span style="color: #333333">clazz</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">Proxy</span><span style="color: #A71D7E">.</span><span style="color: #008080">getProxyClass</span><span style="color: #A71D7E">(</span><span style="color: #333333">classLoader</span><span style="color: #A71D7E">,</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">Class</span><span style="color: #A71D7E">[]</span> <span style="color: #A71D7E">{</span> <span style="color: #333333">Interface</span><span style="color: #A71D7E">.</span><span style="color: #008080">class</span><span style="color: #A71D7E">,</span> <span style="color: #A71D7E">...</span> <span style="color: #A71D7E">});</span>

<span style="color: #999988; font-style: italic">// 通过反射从生成的类对象获得构造函数对象</span>
<span style="color: #333333">Constructor</span> <span style="color: #333333">constructor</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">clazz</span><span style="color: #A71D7E">.</span><span style="color: #008080">getConstructor</span><span style="color: #A71D7E">(</span><span style="color: #A71D5D">new</span> <span style="color: #333333">Class</span><span style="color: #A71D7E">[]</span> <span style="color: #A71D7E">{</span> <span style="color: #333333">InvocationHandler</span><span style="color: #A71D7E">.</span><span style="color: #008080">class</span> <span style="color: #A71D7E">});</span>

<span style="color: #999988; font-style: italic">// 通过构造函数对象创建动态代理类实例</span>
<span style="color: #333333">Interface</span> <span style="color: #333333">Proxy</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D7E">(</span><span style="color: #333333">Interface</span><span style="color: #A71D7E">)</span><span style="color: #333333">constructor</span><span style="color: #A71D7E">.</span><span style="color: #008080">newInstance</span><span style="color: #A71D7E">(</span><span style="color: #A71D5D">new</span> <span style="color: #333333">Object</span><span style="color: #A71D7E">[]</span> <span style="color: #A71D7E">{</span> <span style="color: #333333">handler</span> <span style="color: #A71D7E">});</span>
</pre></div>

<br>
Proxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装, 简化了动态代理对象的获取过程.</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">// InvocationHandlerImpl 实现了 InvocationHandler 接口, 并能实现方法调用从代理类到委托类的分派转发</span>
<span style="color: #333333">InvocationHandler</span> <span style="color: #333333">handler</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">InvocationHandlerImpl</span><span style="color: #A71D7E">(..);</span>

<span style="color: #999988; font-style: italic">// 通过 Proxy 直接创建动态代理类实例</span>
<span style="color: #333333">Interface</span> <span style="color: #333333">proxy</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D7E">(</span><span style="color: #333333">Interface</span><span style="color: #A71D7E">)</span><span style="color: #333333">Proxy</span><span style="color: #A71D7E">.</span><span style="color: #008080">newProxyInstance</span><span style="color: #A71D7E">(</span><span style="color: #333333">classLoader</span><span style="color: #A71D7E">,</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">Class</span><span style="color: #A71D7E">[]</span> <span style="color: #A71D7E">{</span> <span style="color: #333333">Interface</span><span style="color: #A71D7E">.</span><span style="color: #008080">class</span> <span style="color: #A71D7E">},</span> <span style="color: #333333">handler</span><span style="color: #A71D7E">);</span>
</pre></div>

<br></p>
<h2 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>示例</h2>
<p>创建自己的调用处理器</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">/**</span>
<span style="color: #999988; font-style: italic"> * 动态代理类对应的调用处理程序类</span>
<span style="color: #999988; font-style: italic"> */</span>
<span style="color: #A71D5D">public</span> <span style="color: #A71D5D">class</span> <span style="color: #445588">SubjectInvocationHandler</span> <span style="color: #A71D5D">implements</span> <span style="color: #333333">InvocationHandler</span> <span style="color: #A71D7E">{</span>

 <span style="color: #999988; font-style: italic">//代理类持有一个委托类的对象引用</span>
 <span style="color: #A71D5D">private</span> <span style="color: #333333">Object</span> <span style="color: #333333">delegate</span><span style="color: #A71D7E">;</span>

 <span style="color: #A71D5D">public</span> <span style="color: #795DA3">SubjectInvocationHandler</span><span style="color: #A71D7E">(</span><span style="color: #333333">Object</span> <span style="color: #333333">delegate</span><span style="color: #A71D7E">)</span> <span style="color: #A71D7E">{</span>
  <span style="color: #A71D5D">this</span><span style="color: #A71D7E">.</span><span style="color: #008080">delegate</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">delegate</span><span style="color: #A71D7E">;</span>
 <span style="color: #A71D7E">}</span>

 <span style="color: #333333">@Override</span>
 <span style="color: #A71D5D">public</span> <span style="color: #333333">Object</span> <span style="color: #795DA3">invoke</span><span style="color: #A71D7E">(</span><span style="color: #333333">Object</span> <span style="color: #333333">proxy</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Method</span> <span style="color: #333333">method</span><span style="color: #A71D7E">,</span> <span style="color: #333333">Object</span><span style="color: #A71D7E">[]</span> <span style="color: #333333">args</span><span style="color: #A71D7E">)</span> <span style="color: #A71D5D">throws</span> <span style="color: #333333">Throwable</span> <span style="color: #A71D7E">{</span>
  <span style="color: #A71D5D; font-weight: bold">long</span> <span style="color: #333333">stime</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">System</span><span style="color: #A71D7E">.</span><span style="color: #008080">currentTimeMillis</span><span style="color: #A71D7E">();</span>
  <span style="color: #999988; font-style: italic">//利用反射机制将请求分派给委托类处理. Method的invoke返回Object对象作为方法执行结果.</span>
  <span style="color: #999988; font-style: italic">//因为示例程序没有返回值, 所以这里忽略了返回值处理</span>
  <span style="color: #333333">method</span><span style="color: #A71D7E">.</span><span style="color: #008080">invoke</span><span style="color: #A71D7E">(</span><span style="color: #333333">delegate</span><span style="color: #A71D7E">,</span> <span style="color: #333333">args</span><span style="color: #A71D7E">);</span>
  <span style="color: #A71D5D; font-weight: bold">long</span> <span style="color: #333333">ftime</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">System</span><span style="color: #A71D7E">.</span><span style="color: #008080">currentTimeMillis</span><span style="color: #A71D7E">();</span>
  <span style="color: #333333">System</span><span style="color: #A71D7E">.</span><span style="color: #008080">out</span><span style="color: #A71D7E">.</span><span style="color: #008080">println</span><span style="color: #A71D7E">(</span><span style="color: #183691">&quot;执行任务耗时&quot;</span><span style="color: #A71D7E">+(</span><span style="color: #333333">ftime</span> <span style="color: #A71D7E">-</span> <span style="color: #333333">stime</span><span style="color: #A71D7E">)+</span><span style="color: #183691">&quot;毫秒&quot;</span><span style="color: #A71D7E">);</span>

  <span style="color: #A71D5D">return</span> <span style="color: #A71D5D">null</span><span style="color: #A71D7E">;</span>
 <span style="color: #A71D7E">}</span>
<span style="color: #A71D7E">}</span>
</pre></div>

<br>
生成动态代理对象的工厂, 工厂方法列出了如何生成动态代理类对象的步骤.</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">/**</span>
<span style="color: #999988; font-style: italic"> * 生成动态代理对象的工厂.</span>
<span style="color: #999988; font-style: italic"> */</span>
<span style="color: #A71D5D">public</span> <span style="color: #A71D5D">class</span> <span style="color: #445588">DynProxyFactory</span> <span style="color: #A71D7E">{</span>
 <span style="color: #999988; font-style: italic">//客户类调用此工厂方法获得代理对象.</span>
 <span style="color: #999988; font-style: italic">//对客户类来说, 其并不知道返回的是代理类对象还是委托类对象.</span>
 <span style="color: #A71D5D">public</span> <span style="color: #A71D5D">static</span> <span style="color: #333333">Subject</span> <span style="color: #795DA3">getInstance</span><span style="color: #A71D7E">(){</span>
  <span style="color: #333333">Subject</span> <span style="color: #333333">delegate</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">RealSubject</span><span style="color: #A71D7E">();</span>
  <span style="color: #333333">InvocationHandler</span> <span style="color: #333333">handler</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D5D">new</span> <span style="color: #333333">SubjectInvocationHandler</span><span style="color: #A71D7E">(</span><span style="color: #333333">delegate</span><span style="color: #A71D7E">);</span>
  <span style="color: #333333">Subject</span> <span style="color: #333333">proxy</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D5D">null</span><span style="color: #A71D7E">;</span>
  <span style="color: #333333">proxy</span> <span style="color: #A71D7E">=</span> <span style="color: #A71D7E">(</span><span style="color: #333333">Subject</span><span style="color: #A71D7E">)</span><span style="color: #333333">Proxy</span><span style="color: #A71D7E">.</span><span style="color: #008080">newProxyInstance</span><span style="color: #A71D7E">(</span>
    <span style="color: #333333">delegate</span><span style="color: #A71D7E">.</span><span style="color: #008080">getClass</span><span style="color: #A71D7E">().</span><span style="color: #008080">getClassLoader</span><span style="color: #A71D7E">(),</span>
    <span style="color: #333333">delegate</span><span style="color: #A71D7E">.</span><span style="color: #008080">getClass</span><span style="color: #A71D7E">().</span><span style="color: #008080">getInterfaces</span><span style="color: #A71D7E">(),</span>
    <span style="color: #333333">handler</span><span style="color: #A71D7E">);</span>
  <span style="color: #A71D5D">return</span> <span style="color: #333333">proxy</span><span style="color: #A71D7E">;</span>
 <span style="color: #A71D7E">}</span>
<span style="color: #A71D7E">}</span>
</pre></div>

<br>
动态代理客户类</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #A71D5D">public</span> <span style="color: #A71D5D">class</span> <span style="color: #445588">Client</span> <span style="color: #A71D7E">{</span>

 <span style="color: #A71D5D">public</span> <span style="color: #A71D5D">static</span> <span style="color: #A71D5D; font-weight: bold">void</span> <span style="color: #795DA3">main</span><span style="color: #A71D7E">(</span><span style="color: #333333">String</span><span style="color: #A71D7E">[]</span> <span style="color: #333333">args</span><span style="color: #A71D7E">)</span> <span style="color: #A71D7E">{</span>

  <span style="color: #333333">Subject</span> <span style="color: #333333">proxy</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">DynProxyFactory</span><span style="color: #A71D7E">.</span><span style="color: #008080">getInstance</span><span style="color: #A71D7E">();</span>
  <span style="color: #333333">proxy</span><span style="color: #A71D7E">.</span><span style="color: #008080">dealTask</span><span style="color: #A71D7E">(</span><span style="color: #183691">&quot;DBQueryTask&quot;</span><span style="color: #A71D7E">);</span>
 <span style="color: #A71D7E">}</span>

<span style="color: #A71D7E">}</span>
</pre></div>

<br></p>
<p class="subheader">Category: <a href="http://blog.smallcpp.com/category/da-shu-ju.html">大数据</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="054-fan-she-zhi-dong-tai-dai-li" data-title="054、反射之动态代理" data-url="http://blog.smallcpp.com/054-fan-she-zhi-dong-tai-dai-li.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.com/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/category/ban-ben-kong-zhi.html">版本控制</a></li>
            <li><a href="http://blog.smallcpp.com/category/c11-xin-te-xing.html">C++11 新特性</a></li>
            <li><a href="http://blog.smallcpp.com/category/cocos2d-you-xi-kai-fa.html">Cocos2d 游戏开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.com/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.com/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.com/category/hadoop.html">hadoop</a></li>
            <li><a href="http://blog.smallcpp.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.com/category/ling-ji-chu-qt-ru-men.html">零基础 QT 入门</a></li>
            <li><a href="http://blog.smallcpp.com/category/linux.html">Linux</a></li>
            <li><a href="http://blog.smallcpp.com/category/lua-you-xi-kai-fa.html">Lua 游戏开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/pyqt-kai-fa.html">PyQt 开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a></li>
            <li><a href="http://blog.smallcpp.com/category/shen-ru-qian-chu-mongodb.html">深入浅出 Mongodb</a></li>
            <li><a href="http://blog.smallcpp.com/category/shen-ru-qian-chu-redis.html">深入浅出 Redis</a></li>
            <li><a href="http://blog.smallcpp.com/category/za-xiang.html">杂项</a></li>
            <li><a href="http://blog.smallcpp.com/category/zai-xue-java.html">再学 JAVA</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>