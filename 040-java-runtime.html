<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>040、Java Runtime</title>

    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.cn/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.cn/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.cn">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.cn/040-java-runtime.html" rel="bookmark"
        title="Permalink to 040、Java Runtime">040、Java Runtime</a></h3>
    </header>

<h6 class="subheader" title="2016-07-11T15:40:00+08:00">Mon 11 July 2016
</h6>


    <div class="toc">
<ul>
<li><a href="#_1">一、概述</a></li>
<li><a href="#api">二、API预览</a></li>
<li><a href="#_2">三、常见的应用</a><ul>
<li><a href="#1">1、内存管理</a></li>
<li><a href="#2">2、执行其他程序</a></li>
</ul>
</li>
</ul>
</div>
<p>Reference: <a href="http://lavasoft.blog.51cto.com/62575/15565/">深入研究 java.lang.Runtime 类</a></p>
<h1 id="_1">一、概述</h1>
<p>Runtime 类封装了运行时的环境, 每个 Java 应用程序都有一个 Runtime 类实例, 使应用程序能够与其运行的环境相连接.</p>
<p>一般不能实例化一个 Runtime 对象, 应用程序也不能创建自己的 Runtime 类实例, 但可以通过 getRuntime 方法获取当前 Runtime 运行时对象的引用.</p>
<p>一旦得到了一个当前的 Runtime 对象的引用, 就可以调用 Runtime 对象的方法去控制 Java 虚拟机的状态和行为.</p>
<h1 id="api">二、API预览</h1>
<ul>
<li><code>addShutdownHook(Thread hook)</code><ul>
<li>注册新的虚拟机来关闭挂钩</li>
</ul>
</li>
<li><code>availableProcessors()</code><ul>
<li>向 Java 虚拟机返回可用处理器的数目</li>
</ul>
</li>
<li><code>exec(String command)</code><ul>
<li>在单独的进程中执行指定的字符串命令</li>
</ul>
</li>
<li><code>exec(String[] cmdarray)</code><ul>
<li>在单独的进程中执行指定命令和变量</li>
</ul>
</li>
<li><code>exec(String[] cmdarray, String[] envp)</code><ul>
<li>在指定环境的独立进程中执行指定命令和变量</li>
</ul>
</li>
<li><code>exec(String[] cmdarray, String[] envp, File dir)</code><ul>
<li>在指定环境和工作目录的独立进程中执行指定的命令和变量</li>
</ul>
</li>
<li><code>exec(String command, String[] envp)</code><ul>
<li>在指定环境的单独进程中执行指定的字符串命令</li>
</ul>
</li>
<li><code>exec(String command, String[] envp, File dir)</code><ul>
<li>在有指定环境和工作目录的独立进程中执行指定的字符串命令</li>
</ul>
</li>
<li><code>exit(int status)</code><ul>
<li>通过启动虚拟机的关闭序列, 终止当前正在运行的 Java 虚拟机</li>
</ul>
</li>
<li><code>freeMemory()</code><ul>
<li>返回 Java 虚拟机中的空闲内存量</li>
</ul>
</li>
<li><code>gc()</code><ul>
<li>运行垃圾回收器</li>
</ul>
</li>
<li><code>InputStream getLocalizedInputStream(InputStream in)</code><ul>
<li>已过时. 从 JDK 1.1 开始, 将本地编码字节流转换为 Unicode 字符流的首选方法是使用 InputStreamReader 和 BufferedReader 类</li>
</ul>
</li>
<li><code>OutputStream getLocalizedOutputStream(OutputStream out)</code><ul>
<li>已过时. 从 JDK 1.1 开始, 将 Unicode 字符流转换为本地编码字节流的首选方法是使用 OutputStreamWriter、BufferedWriter 和 PrintWriter 类</li>
</ul>
</li>
<li><code>getRuntime()</code><ul>
<li>返回与当前 Java 应用程序相关的运行时对象</li>
</ul>
</li>
<li><code>halt(int status)</code><ul>
<li>强行终止目前正在运行的 Java 虚拟机</li>
</ul>
</li>
<li><code>load(String filename)</code><ul>
<li>加载作为动态库的指定文件名</li>
</ul>
</li>
<li><code>loadLibrary(String libname)</code><ul>
<li>加载具有指定库名的动态库</li>
</ul>
</li>
<li><code>maxMemory()</code><ul>
<li>返回 Java 虚拟机试图使用的最大内存量</li>
</ul>
</li>
<li><code>removeShutdownHook(Thread hook)</code><ul>
<li>取消注册某个先前已注册的虚拟机关闭挂钩</li>
</ul>
</li>
<li><code>runFinalization()</code><ul>
<li>运行挂起 finalization 的所有对象的终止方法</li>
</ul>
</li>
<li><code>runFinalizersOnExit(value)</code><ul>
<li>已过时. 此方法本身具有不安全性. 它可能对正在使用的对象调用终结方法, 而其他线程正在操作这些对象, - 从而导致不正确的行为或死锁</li>
</ul>
</li>
<li><code>totalMemory()</code><ul>
<li>返回 Java 虚拟机中的内存总量</li>
</ul>
</li>
<li><code>traceInstructions(on)</code><ul>
<li>启用／禁用指令跟踪</li>
</ul>
</li>
<li><code>traceMethodCalls(on)</code><ul>
<li>启用／禁用方法调用跟踪</li>
</ul>
</li>
</ul>
<h1 id="_2">三、常见的应用</h1>
<h2 id="1">1、内存管理</h2>
<p>Java 提供了无用单元自动收集机制, 通过 <code>totalMemory()</code>和 <code>freeMemory()</code> 方法可以知道对象的堆内存有多大, 还剩多少.</p>
<p>Java 会周期性的回收垃圾对象 (未使用的对象), 以便释放内存空间. 但是如果想先于收集器的下一次指定周期来收集废弃的对象, 可以通过调用 <code>gc()</code> 方法来根据需要运行无用单元收集器.</p>
<p>一个很好的试验方法是先调用 <code>gc()</code> 方法, 然后调用 <code>freeMemory()</code> 方法来查看基本的内存使用情况, 接着执行代码, 然后再次调用 <code>freeMemory()</code> 方法看看分配了多少内存.</p>
<p>下面的程序演示了这个构想. // 此实例来自《java 核心技术》卷一</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">MemoryDemo</span> {
    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">main</span>(String args[]) {
        Runtime r = Runtime.<span style="color: #658b00">getRuntime</span>();
        <span style="color: #00688B; font-weight: bold">long</span> mem1,mem2;
        Integer someints[] = <span style="color: #8B008B; font-weight: bold">new</span> Integer[<span style="color: #B452CD">1000</span>];
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Total memory is ：&quot;</span> + r.<span style="color: #658b00">totalMemory</span>());
        mem1 = r.<span style="color: #658b00">freeMemory</span>();
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Initial free is : &quot;</span> + mem1);
        r.<span style="color: #658b00">gc</span>();
        mem1 = r.<span style="color: #658b00">freeMemory</span>();
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Free memory after garbage collection : &quot;</span> + mem1);
        <span style="color: #228B22">//allocate integers</span>
        <span style="color: #8B008B; font-weight: bold">for</span>(<span style="color: #00688B; font-weight: bold">int</span> i=<span style="color: #B452CD">0</span>; i&lt;<span style="color: #B452CD">1000</span>; i++) someints[i] = <span style="color: #8B008B; font-weight: bold">new</span> Integer(i);
        mem2 = r.<span style="color: #658b00">freeMemory</span>();
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Free memory after allocation : &quot;</span> + mem2);
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Memory used by allocation : &quot;</span> +(mem1-mem2));
        <span style="color: #228B22">//discard Intergers</span>
        <span style="color: #8B008B; font-weight: bold">for</span>(<span style="color: #00688B; font-weight: bold">int</span> i=<span style="color: #B452CD">0</span>; i&lt;<span style="color: #B452CD">1000</span>; i++) someints[i] = <span style="color: #8B008B; font-weight: bold">null</span>;
        r.<span style="color: #658b00">gc</span>(); <span style="color: #228B22">//request garbage collection</span>
        mem2 = r.<span style="color: #658b00">freeMemory</span>();
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Free memory after collecting &quot;</span> + <span style="color: #CD5555">&quot;discarded integers : &quot;</span> + mem2);
    }
}
</pre></div>


<p><br>
编译后运行结果如下 (不同的机器不同时间运行的结果也不一定一样):</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>Total memory is ：2031616
Initial free is : 1818488
Free memory after garbage collection : 1888808
Free memory after allocation : 1872224
Memory used by allocation : 16584
Free memory after collecting discarded integers : 1888808
</pre></div>


<p><br></p>
<h2 id="2">2、执行其他程序</h2>
<p>在安全的环境中, 可以在多任务操作系统中使用 Java 去执行其他特别大的进程 (也就是程序).</p>
<p><code>exec()</code> 方法有几种形式命名想要运行的程序和它的输入参数.</p>
<p><code>exec()</code> 方法返回一个 Process 对象, 可以使用这个对象控制 Java 程序与新运行的进程进行交互.</p>
<p><code>exec()</code> 方法本质是依赖于环境.</p>
<p>下面的例子是使用 <code>exec()</code> 方法启动 windows 的记事本 notepad. / /此实例来自《Java 核心技术》卷一</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">ExecDemo</span> {
    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">main</span>(String args[]) {
        Runtime r = Runtime.<span style="color: #658b00">getRuntime</span>();
        Process p = <span style="color: #8B008B; font-weight: bold">null</span>;
        <span style="color: #8B008B; font-weight: bold">try</span> {
            p = r.<span style="color: #658b00">exec</span>(<span style="color: #CD5555">&quot;notepad&quot;</span>);
        } <span style="color: #8B008B; font-weight: bold">catch</span> (Exception e) {
            System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Error executing notepad.&quot;</span>);
        }
    }
}
</pre></div>


<p><br>
<code>exec()</code> 还有其他几种形式, 例子中演示的是最常用的一种.</p>
<p><code>exec()</code> 方法返回 Process 对象后, 在新程序开始运行后就可以使用 Process 的方法了.</p>
<p>可以用 <code>destory()</code> 方法杀死子进程, 也可以使用 <code>waitFor()</code> 方法等待程序直到子程序结束, <code>exitValue()</code> 方法返回子进程结束时返回的值, 如果没有错误, 将返回 0, 否则返回非 0.</p>
<p>下面是关于 `exec()``方法的例子的改进版本. 例子被修改为等待, 直到运行的进程退出: // 此实例来自《Java 核心技术》卷一</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">ExecDemoFini</span> {
    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">main</span>(String args[]) {
    Runtime r = Runtime.<span style="color: #658b00">getRuntime</span>();
    Process p = <span style="color: #8B008B; font-weight: bold">null</span>;
    <span style="color: #8B008B; font-weight: bold">try</span>{
        p = r.<span style="color: #658b00">exec</span>(<span style="color: #CD5555">&quot;notepad&quot;</span>);
        p.<span style="color: #658b00">waitFor</span>();
    } <span style="color: #8B008B; font-weight: bold">catch</span> (Exception e) {
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Error executing notepad.&quot;</span>);
    }
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;Notepad returned &quot;</span> + p.<span style="color: #658b00">exitValue</span>());
    }
}
</pre></div>


<p><br>
下面是运行的结果 (当关闭记事本后, 会接着运行程序, 打印信息):</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>Notepad returned 0
请按任意键继续. . .
</pre></div>


<p><br>
当子进程正在运行时, 可以对标准输入输出进行读写, <code>getOutputStream()</code> 方法和 <code>getInPutStream()</code> 方法返回对子进程的标准输入和输出.</p>
<p class="subheader">Category: <a href="http://blog.smallcpp.cn/category/java-ru-men-dao-jing-tong.html">Java 入门到精通</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="040-java-runtime" data-title="040、Java Runtime" data-url="http://blog.smallcpp.cn/040-java-runtime.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.cn/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/category/c11.html">C++11</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.cn/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.cn/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.cn/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.cn/category/java-ru-men-dao-jing-tong.html">Java 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/linux-ru-men-dao-jing-tong.html">Linux 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/lua.html">Lua</a></li>
            <li><a href="http://blog.smallcpp.cn/category/mongodb-ru-men-dao-jing-tong.html">Mongodb 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/pyqt.html">PyQt</a></li>
            <li><a href="http://blog.smallcpp.cn/category/python.html">Python</a></li>
            <li><a href="http://blog.smallcpp.cn/category/qt.html">QT</a></li>
            <li><a href="http://blog.smallcpp.cn/category/qu-kuai-lian.html">区块链</a></li>
            <li><a href="http://blog.smallcpp.cn/category/redis-ru-men-dao-jing-tong.html">Redis 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/ruan-jian-she-ji.html">软件设计</a></li>
            <li><a href="http://blog.smallcpp.cn/category/za-xiang.html">杂项</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>