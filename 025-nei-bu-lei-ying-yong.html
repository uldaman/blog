<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>025、内部类应用</title>

    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.cn/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.cn/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.cn">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.cn/025-nei-bu-lei-ying-yong.html" rel="bookmark"
        title="Permalink to 025、内部类应用">025、内部类应用</a></h3>
    </header>

<h6 class="subheader" title="2016-03-16T15:21:00+08:00">Wed 16 March 2016
</h6>


    <div class="toc">
<ul>
<li><a href="#1">1. 多重继承</a></li>
<li><a href="#2">2. 闭包与回调</a></li>
</ul>
</div>
<h2 id="1">1. 多重继承</h2>
<p>内部类最吸引的原因是: 每个内部类都能独立地继承/实现一个类/接口.</p>
<p>这样就为类提供了__&rdquo;多重继承&rdquo;__的可能.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">D</span> {
}

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">E</span> {
}

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">O</span> <span style="color: #8B008B; font-weight: bold">extends</span> D { <span style="color: #228B22">// 外部类继承 D</span>

    <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">I</span> <span style="color: #8B008B; font-weight: bold">extends</span> E { <span style="color: #228B22">// 内部类继承 E</span>
    }

    <span style="color: #8B008B; font-weight: bold">public</span> E <span style="color: #008b45">makeE</span>() {
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #8B008B; font-weight: bold">new</span> I();
    }
}

<span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">TestDemo</span> {
    <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">takesD</span>(D d) {
    }

    <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">takesE</span>(E e) {
    }

    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">main</span>(String[] args) {
        O o = <span style="color: #8B008B; font-weight: bold">new</span> O();
        takesD(o);
        takesE(o.<span style="color: #658b00">makeE</span>());
    }
}
</pre></div>


<p>如上面的代码, 我们的类 O 本身继承了 D, 又可以通过 makeE() 方法返回一个继承 E 的对象, 这就相当于&rdquo;多重继承&rdquo;: 让类 O &ldquo;拥有&rdquo;了类 D 和 类 E 的特征.<br>
如果你还有一个类需要被继承, 可以在类 O 里再添加一个内部类, 用它来继承那个类.</p>
<h2 id="2">2. 闭包与回调</h2>
<blockquote>
<p>闭包貌似是在 Java8 中才被引进的, 但我在使用其他语言(Lua、Python)时, 早已接触过闭包了.</p>
</blockquote>
<p>在 Lua 中, 可以这么解释闭包:<br>
如果在一个内部函数里, 对外部作用域(但又不是在全局作用域)的变量进行引用, 那么内部函数就被认为是闭包(closure).</p>
<p>更官方的一点定义是:<br>
闭包(closure)是一个可调用的对象, 它记录了一些信息, 这些信息来自于创建它的作用域.</p>
<p>通过这个定义, 可以看出, java 中的内部类就是一个面向对象的闭包, 因为它不仅包含其外部类对象(创建内部类的作用域)的信息, 还自动拥有一个__指向此外部类对象的引用__, 在此作用域内, 内部类有权操作外部类的所有成员.</p>
<p>而所谓的__回调__, 就是通过传递对象的一些信息, 然后在稍后的某个时刻允许这些信息调用其初始的对象, 在 C 中这一般通过传递对象的指针来实现, 而指针的弊端嘛&hellip;大家都懂的;</p>
<p>在 Java 中, 内部类提供的闭包功能是一个优良的替代方案, 它比指针灵活、安全.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">interface</span> <span style="color: #008b45; font-weight: bold">Incrementable</span> { <span style="color: #228B22">// 一个计数器接口</span>
    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">increment</span>();
}

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Caller</span> {
    <span style="color: #8B008B; font-weight: bold">private</span> Incrementable callbackReference;

    Caller(Incrementable cbh) {
        callbackReference = cbh;
    }

    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">run</span>() {
        callbackReference.<span style="color: #658b00">increment</span>(); <span style="color: #228B22">// 通过引用回调 increment() 方法</span>
    }
}

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Callee1</span> <span style="color: #8B008B; font-weight: bold">implements</span> Incrementable { <span style="color: #228B22">// 实现接口</span>
    <span style="color: #8B008B; font-weight: bold">private</span> <span style="color: #00688B; font-weight: bold">int</span> i = <span style="color: #B452CD">0</span>;

    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">increment</span>() {
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;一个计数器&quot;</span>);
        i++;
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(i);
    }
}

<span style="color: #8B008B; font-weight: bold">abstract</span> <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">MyIncrement</span> { <span style="color: #228B22">// 一个计数器抽象类</span>
    <span style="color: #8B008B; font-weight: bold">abstract</span> <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">increment</span>();
}

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Callee2</span> <span style="color: #8B008B; font-weight: bold">extends</span> MyIncrement {
    <span style="color: #8B008B; font-weight: bold">private</span> <span style="color: #00688B; font-weight: bold">int</span> i = <span style="color: #B452CD">10</span>;

    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">increment</span>() { <span style="color: #228B22">// 重写</span>
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(<span style="color: #CD5555">&quot;另一个计数器&quot;</span>);
        i++;
        System.<span style="color: #658b00">out</span>.<span style="color: #658b00">println</span>(i);
    }

    <span style="color: #8B008B; font-weight: bold">private</span> <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Closure</span> <span style="color: #8B008B; font-weight: bold">implements</span> Incrementable {
        <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">increment</span>() { <span style="color: #228B22">// 实现, 提供一个外部类的 Hook</span>
            Callee2.<span style="color: #658b00">this</span>.<span style="color: #658b00">increment</span>();
        }
    }

    <span style="color: #8B008B; font-weight: bold">public</span> Incrementable <span style="color: #008b45">getCallbackReference</span>() { <span style="color: #228B22">// 返回一个 Incrementable 引用, 任何人拿到这个引用也只能调用 increment() 方法</span>
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #8B008B; font-weight: bold">new</span> Closure();
    }

    <span style="color: #228B22">// 其它方法</span>
}

<span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">TestDemo</span> {

    <span style="color: #8B008B; font-weight: bold">public</span> <span style="color: #8B008B; font-weight: bold">static</span> <span style="color: #00688B; font-weight: bold">void</span> <span style="color: #008b45">main</span>(String[] args) {
        Callee1 c1 = <span style="color: #8B008B; font-weight: bold">new</span> Callee1();
        Caller caller1 = <span style="color: #8B008B; font-weight: bold">new</span> Caller(c1); <span style="color: #228B22">// 设置回调</span>
        caller1.<span style="color: #658b00">run</span>();

        Callee2 c2 = <span style="color: #8B008B; font-weight: bold">new</span> Callee2();
        Caller caller2 = <span style="color: #8B008B; font-weight: bold">new</span> Caller(c2.<span style="color: #658b00">getCallbackReference</span>()); <span style="color: #228B22">// 设置回调</span>
        caller2.<span style="color: #658b00">run</span>();
    }
}
</pre></div>


<p>Caller 的构造函数需要一个 Incrementable 的引用来作为参数, 然后在稍后的某个时刻, Caller 对象可以使用此引用回调 increment() 方法.</p>
<blockquote>
<p>回调价值在于它的灵活性, 可以在运行时动态地决定需要调用什么方法(根据你传递的引用参数).</p>
</blockquote>
<p>假设我们需要一个计数功能, Callee1 是一个简单的解决方法, 它单独地去实现 Incrementable 接口, 然后传给 Caller 的构造函数, 这没什么好说的.</p>
<p>主要看 Callee2, 它继承于 MyIncrement, 它也有一个 increment() 方法, 我们希望能够让 Caller 去回调这个方法, 但是可惜的是 Callee2 并不实现 Incrementable 接口, 所以不能传递给 Caller 的构造函数.</p>
<p>所幸, 我们还有内部类 Closure, 这个内部类实现了 Incrementable, 并提供一个其外部类 Callee2 的 &ldquo;Hook&rdquo;, 而且是一个安全的 &ldquo;Hook&rdquo;, 这样, 无论谁拿到 Closure 引用, 都只能调用 Callee2 的 increment() 方法, 而不能去操作 Callee2 的其它成员.</p>
<p>这也是为什么说内部类比指针更灵活, 安全的原因.<br>
因为, 如果你得到了某个对象的指针, 相当于拥有了这个对象的完全控制权, 而内部类不一样, 它是可控的, 你可以在内部类中指定要 &ldquo;Hook&rdquo; 的成员, 例如刚才的例子, 我们就只 &ldquo;Hook&rdquo; 了 increment() 方法.</p>
<p class="subheader">Category: <a href="http://blog.smallcpp.cn/category/java-ru-men-dao-jing-tong.html">Java 入门到精通</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="025-nei-bu-lei-ying-yong" data-title="025、内部类应用" data-url="http://blog.smallcpp.cn/025-nei-bu-lei-ying-yong.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.cn/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.cn/category/c11.html">C++11</a></li>
            <li><a href="http://blog.smallcpp.cn/category/cocos2d.html">Cocos2d</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.cn/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.cn/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.cn/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.cn/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.cn/category/java-ru-men-dao-jing-tong.html">Java 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/linux-ru-men-dao-jing-tong.html">Linux 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/lua.html">Lua</a></li>
            <li><a href="http://blog.smallcpp.cn/category/mongodb-ru-men-dao-jing-tong.html">Mongodb 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/pyqt.html">PyQt</a></li>
            <li><a href="http://blog.smallcpp.cn/category/python.html">Python</a></li>
            <li><a href="http://blog.smallcpp.cn/category/qt.html">QT</a></li>
            <li><a href="http://blog.smallcpp.cn/category/qu-kuai-lian.html">区块链</a></li>
            <li><a href="http://blog.smallcpp.cn/category/redis-ru-men-dao-jing-tong.html">Redis 入门到精通</a></li>
            <li><a href="http://blog.smallcpp.cn/category/ruan-jian-she-ji.html">软件设计</a></li>
            <li><a href="http://blog.smallcpp.cn/category/za-xiang.html">杂项</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>