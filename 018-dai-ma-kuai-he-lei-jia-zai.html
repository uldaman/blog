<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>018、代码块和类加载</title>
  <meta name="description" content="">
  <meta name="author" content="martin">

  <!-- Style Meta Data -->
  <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/notebook.css" type="text/css" />
  <link rel="shortcut icon" href="http://blog.smallcpp.cn/theme/images/avatar.png">

  <!-- Feed Meta Data -->
  <link href="http://blog.smallcpp.cn/" type="application/atom+xml" rel="alternate" title="Small Cpp ATOM Feed" />

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="http://blog.smallcpp.cn/theme/images/avatar.png">

<meta name="twitter:creator" content="">
<meta name="twitter:url" content="http://blog.smallcpp.cn/018-dai-ma-kuai-he-lei-jia-zai.html">
<meta name="twitter:title" content="Small Cpp ~ 018、代码块和类加载">
<meta name="twitter:description" content="Java 中的代码块可分为局部代码块(调用方法时执行)、构造代码块(创建对象时执行)、静态代码块(类加载时执行)三种.">

<!-- Facebook Meta Data -->
<meta property="og:title" content="Small Cpp ~ 018、代码块和类加载" />
<meta property="og:description" content="Java 中的代码块可分为局部代码块(调用方法时执行)、构造代码块(创建对象时执行)、静态代码块(类加载时执行)三种." />
<meta property="og:image" content="theme/images/avatar.png" />
</head>

<body>
  <!-- Sidebar -->
  <aside>
    <p><a href="http://blog.smallcpp.cn"><img id="avatar" src="http://blog.smallcpp.cn/theme/images/avatar.png"></a></p>
    <h1>Small Cpp</h1>
    <p>勿在浮沙筑高台, 练从难处练, 用从易处用.</p>
    <hr>
    <h2>Social</h2>
    <ul class="social">
      <a href="http://blog.csdn.net/u010850265">CSDN</a></li>
    </ul>
    <h2>Categories</h2>
    <ul class="navbar">
      <li><a href="http://blog.smallcpp.cn/category/c11.html">C++11</a></li>
      <li><a href="http://blog.smallcpp.cn/category/da-shu-ju.html">大数据</a></li>
      <li><a href="http://blog.smallcpp.cn/category/du-shu-bi-ji.html">读书笔记</a></li>
      <li><a href="http://blog.smallcpp.cn/category/golang.html">Golang</a></li>
      <li><a href="http://blog.smallcpp.cn/category/hei-ke-ji.html">黑科技</a></li>
      <li class="active"><a href="http://blog.smallcpp.cn/category/java.html">Java</a></li>
      <li><a href="http://blog.smallcpp.cn/category/linux.html">Linux</a></li>
      <li><a href="http://blog.smallcpp.cn/category/lua.html">Lua</a></li>
      <li><a href="http://blog.smallcpp.cn/category/mongodb.html">Mongodb</a></li>
      <li><a href="http://blog.smallcpp.cn/category/pyqt.html">PyQt</a></li>
      <li><a href="http://blog.smallcpp.cn/category/python.html">Python</a></li>
      <li><a href="http://blog.smallcpp.cn/category/qt.html">QT</a></li>
      <li><a href="http://blog.smallcpp.cn/category/qu-kuai-lian.html">区块链</a></li>
      <li><a href="http://blog.smallcpp.cn/category/redis.html">Redis</a></li>
      <li><a href="http://blog.smallcpp.cn/category/ruan-jian-she-ji.html">软件设计</a></li>
      <li><a href="http://blog.smallcpp.cn/category/za-xiang.html">杂项</a></li>
    </ul> 
  </aside>

  <!-- Content -->
  <article>
<section id="content">
    <article>
        <header class="post_list">
            <h2 class="post_title"><a href="http://blog.smallcpp.cn/018-dai-ma-kuai-he-lei-jia-zai.html" rel="bookmark" title="Permalink to 018、代码块和类加载">018、代码块和类加载</a></h2>
            <span>Par </span>
            <a href="http://blog.smallcpp.cn/author/martin.html">@Martin</a>
            <span> dans </span>
            <span class="post_category"><a href="http://blog.smallcpp.cn/category/java.html" rel="bookmark" title="Permalink to Java">[ Java ]</a></span>
            <span> le </span>
            <span class="post_date">Mon 07 March 2016</span>
            <div></div>
            <div><span>Tags : </span>
            </div>
        </header>
        <div class="entry-content">
            <div class="toc">
<ul>
<li><a href="#1">1. 代码块</a><ul>
<li><a href="#11">1.1 局部代码块</a></li>
<li><a href="#12">1.2 构造代码块</a></li>
<li><a href="#13">1.3 静态代码块</a></li>
</ul>
</li>
<li><a href="#2">2. 类加载</a><ul>
<li><a href="#21">2.1 首先, 何为类的加载?</a></li>
<li><a href="#22">2.2 类加载阶段的简单说明</a></li>
<li><a href="#23">2.3 手动加载类</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="1">1. 代码块</h1>
<p>Java 中有一种语法, 它将一段代码直接用 <strong>{ }</strong> (花括号)括起来, 这种语法被称做代码块, java 中的代码块根据它出现的位置共分三种:</p>
<ul>
<li>局部代码块</li>
<li>构造代码块</li>
<li>静态代码块</li>
</ul>
<h2 id="11">1.1 局部代码块</h2>
<p>在方法中出现的 { } 就称为局部代码块,  又称普通代码块,  普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定,  即“先出现先执行”.</p>
<h2 id="12">1.2 构造代码块</h2>
<p>直接在类中定义且没有加 static 关键字的代码块称为 { } 构造代码块, 构造代码块在创建对象时被调用, 每次创建对象都会被调用, 并且构造代码块的执行次序优先于类构造函数.</p>
<h2 id="13">1.3 静态代码块</h2>
<p>在类中使用 static 关键字声明的代码块称为 { } 静态代码块,  静态代码块在 jvm 加载类时被执行一次,  一般作用为类的属性初始化.<br>虽然它也有静态二字,  但静态代码块并不能直接访问静态实例变量和实例方法,  需要通过类的实例对象来访问.</p>
<h1 id="2">2. 类加载</h1>
<p>上面说到静态代码块会在 jvm 加载类时被执行一次, 那究竟什么时候 jvm 会去加载类呢?</p>
<h2 id="21">2.1 首先, 何为类的加载?</h2>
<p>一个 java 文件从被加载到被卸载这个生命过程, 总共要经历 5 个阶段:<br>
<strong>装载</strong> -> <strong>链接</strong> (验证 + 准备 + 解析) -> <strong>初始化</strong> -> <strong>使用</strong> (即实例化)-> <strong>卸载</strong></p>
<p>而细分下来, 共包括 <strong>装载</strong> (Loading) 、<strong>验证</strong> (Verification) 、<strong>准备</strong> (Preparation) 、<strong>解析</strong> (Resolution) 、<strong>初始化</strong> (Initialization) 、<strong>使用</strong> (Using) 、<strong>卸载</strong> (Unloading) 等七个阶段, 而类的加载指的就是 <strong>装载</strong> -> <strong>链接</strong> (验证 + 准备 + 解析) -> <strong>初始化</strong> 这<strong>三</strong>个阶段.</p>
<p>虚拟机规范对于何时进行加载这一阶段并没有强制约束, 但对于初始化阶段, 虚拟机规范是严格规定了有且只有<strong>四</strong>种情况必须立即对类进行初始化:</p>
<ul>
<li>使用 <code>new</code> 关键字实例化对象、读取或设置一个类的静态字段以及调用一个类的静态方法的时候 (被 final 修饰的静态字段不属于这些场景).</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时,  如果类没有进行过初始化,  则需要先触发其初始化.</li>
<li>当初始化一个类的时候,  如果发现其父类还没有进行过初始化,  则需要先触发其父类的初始化.</li>
<li>当虚拟机启动时,  用户需要指定一个要执行的主类 (包含 <code>main()</code> 方法的类),  虚拟机会先初始化这个主类.</li>
</ul>
<p>以上四种场景中的行为称为对一个类进行主动引用,  除此之外所有引用类的方式都不会触发初始化,  称为被动引用.</p>
<p><strong>接口的加载过程与类加载过程最主要的区别在于第三点, 即当初始化一个接口时, 并不需要先初始化其父接口, 而是只有真正使用到父接口中的字段的时候才会初始化.</strong></p>
<h2 id="22">2.2 类加载阶段的简单说明</h2>
<p><strong>加载阶段</strong><br>虚拟机需要完成三件事：通过一个类的全限定名来获取定义此类的二进制字节流, 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构, 在 java 堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象, 作为方法区这些数据的访问入口.</p>
<p><strong>验证阶段</strong><br>不同虚拟机会进行不同类验证的实现, 但大致都会完成以下四个阶段的检验过程：文件格式验证 (验证字节流是否符合 Class 文件格式的规范, 并能被当前版本的虚拟机处理) , 元数据验证 (对字节码描述信息进行语义分析, 保证其描述信息符合 java 语言规范) , 字节码验证 (对类方法体进行数据流和控制流分析, 保证类的方法在运行时不会做出危害虚拟机的行为) 和符号引用验证 (发生在将符号引用转化为直接引用的时候, 在解析阶段中发生) .</p>
<p><strong>准备阶段</strong><br>正式为类成员变量 (注意, 不是实例成员变量, 实例变量会在对象实例化时随着对象一起分配在 java 堆上) 分配内存并设置类变量初始值 (通常情况下是数据类型的零值, 不进行赋值操作) 的阶段, 这些内存都将在方法区中进行分配.</p>
<p>例: <code>public static int value=123;</code> 则在准备阶段过后, value 的初始值为 0 而不是 123, 赋值指令是在初始化阶段通过构造方法来执行的.</p>
<p><strong>解析阶段</strong><br>虚拟机将常量池内的符号引用替换为直接引用的过程.符号引用与内存布局无关, 而直接引用的目标必定已经在内存中存在.解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行.</p>
<p><strong>初始化阶段</strong><br>真正开始执行类中定义的 java 程序代码 (字节码) .</p>
<p><strong>所以我们可以看到, 静态代码块其实是在类初始化阶段被执行的.</strong></p>
<h2 id="23">2.3 手动加载类</h2>
<p>Class.forName(xxx.xx.xx) 的作用是要求 JVM 查找并加载指定的类.</p>
<p>Class.forName(xxx.xx.xx) 是运用反射的原理创建对象.<br>
Class.forName(xxx.xx.xx) 返回的是类.<br>
Class.forName(xxx.xx.xx).newInstance() 返回的才是object.</p>
            <div align="center" style="color:#ccc;">☠</div>
        </div>
    </article>
</section>
  </article>


</body>
</html>