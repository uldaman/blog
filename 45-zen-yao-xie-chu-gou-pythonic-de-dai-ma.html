<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>45. 怎么写出够 pythonic 的代码</title>

    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/pygments.css" />	
    <script src="http://z351522453.github.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://z351522453.github.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://z351522453.github.com/45-zen-yao-xie-chu-gou-pythonic-de-dai-ma.html" rel="bookmark"
        title="Permalink to 45. 怎么写出够 pythonic 的代码">45. 怎么写出够 pythonic 的代码</a></h3>
    </header>

<h6 class="subheader" title="2016-05-15T16:09:00+08:00">周日 15 五月 2016
</h6>


    <p>参考资料:<br>
<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python.md">python 性能调优</a><br>
<a href="http://wuzhiwei.net/be_pythonic/">让你的Python代码更加pythonic</a><br>
<a href="http://gold.xitu.io/entry/56010de260b27db45a4f845f">关于 Python 的最全面试题</a></p>
<p>因为我也是从 C++ 转向 Python 的, 所以总感觉自己在用写 C++ 代码的思维写 Python, 没有真正用到其作为脚本语言的优势, 很像披着 Python 外衣的 C++ 代码.</p>
<p>所以才有了这篇笔记, 相当于对之前学过的知识做个小结, 并且收集一些 Pythonic 的代码.</p>
<div class="toc">
<ul>
<li><a href="#_1">列表生成式</a></li>
<li><a href="#_2">生成器表达式</a></li>
<li><a href="#sorted">sorted( )</a></li>
<li><a href="#map">map( )</a></li>
<li><a href="#reduce">reduce( )</a></li>
<li><a href="#filter">filter( )</a></li>
<li><a href="#lambda">lambda 表达式</a></li>
<li><a href="#_3">切片</a></li>
<li><a href="#_4">用正确的数据结构</a></li>
<li><a href="#_5">字符串的优化</a></li>
</ul>
</div>
<h1 id="_1">列表生成式</h1>
<p>提供一个可迭代的对象生成一个新列表</p>
<p><code>[exp for iter_var in iterable]</code></p>
<p><code>[exp for iter_var in iterable if cond_exp]</code></p>
<p>首先迭代 iterable 里所有内容, 每一次迭代, 都把 iterable 里相应内容放到 iter_var 中, 再在表达式 exp 中应用该 iter_var 的内容, 最后用表达式的计算值生成一个新的列表.</p>
<p>例如, 把一个 list 中所有的字符串变成小写:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">L <span style="color: #666666">=</span> [<span style="color: #BB4444">&#39;Hello&#39;</span>, <span style="color: #BB4444">&#39;World&#39;</span>, <span style="color: #BB4444">&#39;IBM&#39;</span>, <span style="color: #BB4444">&#39;Apple&#39;</span>]
[s<span style="color: #666666">.</span>lower() <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> L]
<span style="color: #666666">&gt;&gt;&gt;</span> [<span style="color: #BB4444">&#39;hello&#39;</span>, <span style="color: #BB4444">&#39;world&#39;</span>, <span style="color: #BB4444">&#39;ibm&#39;</span>, <span style="color: #BB4444">&#39;apple&#39;</span>]
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-lie-biao-sheng-cheng-shi.html">Python 高级特性之列表生成式</a></p>
<h1 id="_2">生成器表达式</h1>
<p>当列表过长, 而我们也不需要一次性获取全部数据时, 应当考虑使用生成器(generator)表达式而不是列表解析;</p>
<p>生成器表达式的语法和列表解析一样, 只不过生成器表达式是被（）括起来的, 而不是 [ ], 如下:</p>
<p><code>(exp for iter_var in iterable)</code></p>
<p><code>(exp for iter_var in iterable if cond_exp)</code></p>
<p>生成器表达式使用了 &ldquo;惰性计算&rdquo; (lazy evaluation, 也有翻译为 &ldquo;延迟求值&rdquo;, 我以为这种按需调用 call by need 的方式翻译为惰性更好一些), 只有在检索时才被赋值 (evaluated), 所以在列表比较长的情况下使用更有效 (节省内存).</p>
<p>参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-sheng-cheng-qi-biao-da-shi.html">Python 高级特性之生成器表达式</a></p>
<h1 id="sorted">sorted( )</h1>
<p>sorted 语法如下:</p>
<p><code>sorted(iterable, cmp = None, key = None, reverse = False)</code></p>
<ul>
<li>iterable: 是可迭代类型</li>
<li>cmp: 定制一个接收两个参数比较函数, 比较什么由下一个参数 key 决定</li>
<li>key: 指定一个接收一个参数的函数, 这个函数用于从序列的每个元素中提取一个用于排序的依据</li>
<li>reverse: 排序规则. reverse = True 或者 reverse = False</li>
<li>返回值: 是一个经过排序的可迭代类型, 与 iterable 一样</li>
</ul>
<blockquote>
<p>一般来说, cmp 和 key 可以使用 lambda 表达式</p>
</blockquote>
<p>正序:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">sorted</span>([<span style="color: #666666">36</span>, <span style="color: #666666">5</span>, <span style="color: #666666">12</span>, <span style="color: #666666">9</span>, <span style="color: #666666">21</span>])
<span style="color: #666666">&gt;&gt;&gt;</span>[<span style="color: #666666">5</span>, <span style="color: #666666">9</span>, <span style="color: #666666">12</span>, <span style="color: #666666">21</span>, <span style="color: #666666">36</span>]
</pre></div>


<p><br>
倒序:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">sorted</span>([<span style="color: #666666">36</span>, <span style="color: #666666">5</span>, <span style="color: #666666">12</span>, <span style="color: #666666">9</span>, <span style="color: #666666">21</span>], reverse <span style="color: #666666">=</span> <span style="color: #AA22FF">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span>[<span style="color: #666666">36</span>, <span style="color: #666666">21</span>, <span style="color: #666666">12</span>, <span style="color: #666666">9</span>, <span style="color: #666666">5</span>]
</pre></div>


<p><br>
如果想自己实现倒序排序, 则可以自己写 <strong>cmp</strong> 函数, 然后做为 sorted() 的第二个参数.</p>
<p>通常规定, 对于两个元素 x 和 y:</p>
<ul>
<li>如果认为 x &lt; y, 则返回 -1</li>
<li>如果认为 x == y, 则返回 0</li>
<li>如果认为 x &gt; y, 则返回 1</li>
</ul>
<p>我们来实现倒序:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">reversed_cmp</span>(x, y):
    <span style="color: #AA22FF; font-weight: bold">if</span> x <span style="color: #666666">&gt;</span> y:
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">-1</span>
    <span style="color: #AA22FF; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> y:
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">1</span>
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">0</span>
</pre></div>


<p><br>
传入自定义的比较函数 reversed_cmp, 就可以实现倒序排序:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">sorted</span>([<span style="color: #666666">36</span>, <span style="color: #666666">5</span>, <span style="color: #666666">12</span>, <span style="color: #666666">9</span>, <span style="color: #666666">21</span>], reversed_cmp)
<span style="color: #666666">&gt;&gt;&gt;</span>[<span style="color: #666666">36</span>, <span style="color: #666666">21</span>, <span style="color: #666666">12</span>, <span style="color: #666666">9</span>, <span style="color: #666666">5</span>]
</pre></div>


<p><br>
再来看年 sorted() 的 <strong>key</strong> 参数:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">L <span style="color: #666666">=</span> [(<span style="color: #BB4444">&#39;b&#39;</span>,<span style="color: #666666">2</span>),(<span style="color: #BB4444">&#39;a&#39;</span>,<span style="color: #666666">1</span>),(<span style="color: #BB4444">&#39;c&#39;</span>,<span style="color: #666666">3</span>),(<span style="color: #BB4444">&#39;d&#39;</span>,<span style="color: #666666">4</span>)]
<span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #AA22FF">sorted</span>(L, key <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">lambda</span> x : x[<span style="color: #666666">1</span>])
<span style="color: #666666">&gt;&gt;&gt;</span>[(<span style="color: #BB4444">&#39;a&#39;</span>, <span style="color: #666666">1</span>), (<span style="color: #BB4444">&#39;b&#39;</span>, <span style="color: #666666">2</span>), (<span style="color: #BB4444">&#39;c&#39;</span>, <span style="color: #666666">3</span>), (<span style="color: #BB4444">&#39;d&#39;</span>, <span style="color: #666666">4</span>)]
</pre></div>


<p><br>
L 中的元素是一个 tupe, key 参数指定用 <code>tupe[1]</code> 做为依据来比较</p>
<p>参考链接:<br>
<a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-sorted.html">Python 高级特性之 sorted( )</a><br>
<a href="http://www.cnblogs.com/woshitianma/p/3222989.html">Python中sorted()方法的用法</a></p>
<h1 id="map">map( )</h1>
<p>map() 函数接收两个参数, 一个是函数, 一个是序列, map() 将传入的函数依次作用到序列的每个元素, 并把结果作为新的 list 返回.</p>
<p>例子, 求 1 到 10 每个数的乘阶:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">fun</span>(x):
    <span style="color: #AA22FF; font-weight: bold">return</span> x <span style="color: #666666">*</span> x

<span style="color: #AA22FF">map</span>(fun, <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">11</span>))
<span style="color: #666666">&gt;&gt;&gt;</span>[<span style="color: #666666">1</span>, <span style="color: #666666">4</span>, <span style="color: #666666">9</span>, <span style="color: #666666">16</span>, <span style="color: #666666">25</span>, <span style="color: #666666">36</span>, <span style="color: #666666">49</span>, <span style="color: #666666">64</span>, <span style="color: #666666">81</span>, <span style="color: #666666">100</span>]
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-map.html">Python 高级特性之 map( )</a></p>
<h1 id="reduce">reduce( )</h1>
<p>reduce() 函数接收两个参数, 一个是函数, 一个是序列;</p>
<p>但传入的这个函数必须接收两个参数, reduce() 会把这个函数运算的结果继续和序列的下一个元素做<strong>累积</strong>运算, 相当于:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">reduce</span>(fun, [x1, x2, x3, x4]) <span style="color: #666666">=</span> fun(fun(fun(x1, x2), x3), x4)
</pre></div>


<p><br>
例子, 对序列求和:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">add</span>(x, y):
    <span style="color: #AA22FF; font-weight: bold">return</span> x <span style="color: #666666">+</span> y

<span style="color: #AA22FF">reduce</span>(add, [<span style="color: #666666">1</span>, <span style="color: #666666">3</span>, <span style="color: #666666">5</span>, <span style="color: #666666">7</span>, <span style="color: #666666">9</span>])
<span style="color: #666666">&gt;&gt;&gt;25</span>
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-reduce.html">Python 高级特性之 reduce( )</a></p>
<h1 id="filter">filter( )</h1>
<p>filter() 函数接收两个参数, 一个是函数, 一个是序列;</p>
<p>filter() 把传入的函数依次作用于每个元素, 然后根据返回值是 True 还是 False 决定保留还是丢弃该元素.</p>
<p>例如, 在一个 list 中, 删掉偶数, 只保留奇数, 可以这么写:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">is_odd</span>(n):
    <span style="color: #AA22FF; font-weight: bold">return</span> n <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">1</span>

<span style="color: #AA22FF">filter</span>(is_odd, <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">11</span>))
<span style="color: #666666">&gt;&gt;&gt;</span>[<span style="color: #666666">1</span>, <span style="color: #666666">3</span>, <span style="color: #666666">5</span>, <span style="color: #666666">7</span>, <span style="color: #666666">9</span>]
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-filter.html">Python 高级特性之 filter( )</a></p>
<h1 id="lambda">lambda 表达式</h1>
<p>当我们在传入函数时, 有些时候, 不需要显式地定义函数, 直接传入匿名函数更方便, 匿名函数也叫 lambda 表达式.</p>
<p>lambda 因为是一个表达式, 所以不要写 return, 返回值就是该表达式的结果.</p>
<p>lambda 语法中, 冒号前是参数, 多个用逗号隔开, 冒号右边的返回值.</p>
<p><code>lambda x: x * x</code> 实际上就是:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">f</span>(x):
    <span style="color: #AA22FF; font-weight: bold">return</span> x <span style="color: #666666">*</span> x
</pre></div>


<p><br>
用 lambda 表达式还有个好处, 因为函数没有名字, 不必担心函数名冲突, 此外, lambda 表达式也是一个函数对象, 也可以把 lambda 表达式赋值给一个变量, 再利用变量来调用该函数.</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">g <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">lambda</span> x : x <span style="color: #666666">**</span> <span style="color: #666666">2</span> <span style="color: #008800; font-style: italic"># x 的平方</span>
v <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">lambda</span> x, y : x <span style="color: #666666">**</span> y <span style="color: #008800; font-style: italic"># x 的 y 次方</span>
</pre></div>


<p><br>
例子, 求 1 到 100 的合:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">reduce</span>(<span style="color: #AA22FF; font-weight: bold">lambda</span> x, y : x <span style="color: #666666">+</span> y, <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">101</span>))
<span style="color: #666666">&gt;&gt;&gt;5050</span>
</pre></div>


<p><br>
lambda 可以配合 map、reduce、filter、sorted 高效操作列表.</p>
<p>参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-lambda.html">Python 高级特性之 lambda</a></p>
<h1 id="_3">切片</h1>
<p>对于具有序列结构的数据来说, 切片操作的语法是:</p>
<p><code>consequence[start_index : end_index : step]</code></p>
<p><code>注意</code>: 对于序列结构数据来说, <strong>xxx_index</strong>和<strong>step</strong>都具有正负两个值, 分别表示左右两个方向取值.</p>
<ul>
<li>start_index: 表示切片的起始位置 (<strong>包含</strong>该位置的元素)<ul>
<li>默认为序列第一个元素, 用正索引表示为 0</li>
<li>默认为序列第一个元素, 用负索引表示为 <code>-len(consequence)</code></li>
</ul>
</li>
<li>end_index: 表示切片的结束位置 (<strong>不包含</strong>该位置的元素)<ul>
<li>默认为序列最后一个元素, 用正索引表示为 <code>len(consequence) - 1</code></li>
<li>默认为序列最后一个元素, 用负索引表示为 -1</li>
</ul>
</li>
<li>step: 表示取值的步长, 默认为 1, 步长值不能为 0<ul>
<li>正数表示向正向递增取值</li>
<li>负数表示向反向递增取值</li>
</ul>
</li>
</ul>
<p><strong>xxx_index</strong>和<strong>step</strong>并不是必须的, 可以有下面这些组合:</p>
<ul>
<li><code>con[start_index]</code>: 返回索引值为 start_index 的对象, start_index 为 -len(con) 到 len(con) - 1 之间任意整数</li>
<li><code>con[start_index : end_index]</code>: 返回索引值为 start_index 到 end_index - 1 之间的连续对象</li>
<li><code>con[start_index : end_index : step]</code>: 从 start_index 开始, 每递增 step 位取个值, 到 end_index - 1 结束</li>
<li><code>con[start_index:]</code>: 缺省 end_index, 表示从 start_index 开始到序列中最后一个对象</li>
<li><code>con[:end_index］</code>: 缺省 start_index, 表示从序列中第一个对象到 end_index - 1 之间的片段</li>
<li><code>con[:]</code>: 缺省 start_index 和 end_index, 表示从第一个对象到最后一个对象的完整片段</li>
<li><code>con[::step]</code>: 缺省 start_index 和 end_index, 表示对序列按 step 正向/反向取值</li>
</ul>
<p>例子, 返转字符串</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">reverse_str</span>( s ):
    <span style="color: #AA22FF; font-weight: bold">return</span> s[::<span style="color: #666666">-1</span>]
</pre></div>


<p><br>
字符串也是一种序列, 因此利用切片就能极方便地反转字符了, 步长为 -1 即反向、每次递增 1 地从序列中取值.</p>
<h1 id="_4">用正确的数据结构</h1>
<p><strong>字典 (dictionary) 与列表 (list)</strong>:<br>
Python 字典中使用了 hash table, 因此查找操作的复杂度为 O(1), 而 list 实际是个数组, 在 list 中, 查找需要遍历整个 list, 其复杂度为 O(n), 因此对成员的查找访问等操作字典要比 list 更快.</p>
<p><strong>集合 (set) 与列表 (list)</strong>:<br>
set 的 union、ntersection、difference 操作要比 list 的迭代要快, 因此如果涉及到求 list 交集, 并集或者差的问题可以转换为 set 来操作.</p>
<ul>
<li>set(list1) | set(list2)：包含 list1 和 list2 所有数据的新集合</li>
<li>set(list1) &amp; set(list2)：包含 list1 和 list2 中共同元素的新集合</li>
<li>set(list1) - set(list2)：在 list1 中出现但不在 list2 中出现的元素的集合</li>
</ul>
<h1 id="_5">字符串的优化</h1>
<p>python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能.</p>
<p><code>使用 join 而不是 + 连接字符串</code></p>
<p>避免类似下面的代码片段:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">s <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;&#39;</span>
<span style="color: #AA22FF; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> somelist:
    s <span style="color: #666666">+=</span> x
</pre></div>


<p><br>
而是要使用下面这种:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">s <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;&#39;</span><span style="color: #666666">.</span>join(somelist)
</pre></div>


<p><br>
当对字符串可以使用<strong>正则表达式</strong>或者内置函数来处理的时候，选择内置函数, 如 str.isalpha()、str.isdigit()、str.startswith((&lsquo;x&rsquo;, &lsquo;yz&rsquo;))、str.endswith((&lsquo;x&rsquo;, &lsquo;yz&rsquo;)) 等.</p>
<p>对字符进行格式化比直接串联读取要快，因此要使用:<br>
<code>out = '&lt;html&gt;%s%s%s%s&lt;/html&gt;'' % (head, prologue, query, tail)</code><br>
而不是:<br>
<code>out = '&lt;html&gt;'' + head + prologue + query + tail + '&lt;/html&gt;'</code></p>
<p class="subheader">Category: <a href="http://z351522453.github.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a>

</p>




</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/archives.html">Archives</a>
            <li><a href="http://z351522453.github.com/tags.html">Tags</a>
        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/category/ban-ben-kong-zhi.html">版本控制</a></li>
            <li><a href="http://z351522453.github.com/category/c11xin-te-xing.html">C++11新特性</a></li>
            <li><a href="http://z351522453.github.com/category/cocos2dyou-xi-kai-fa.html">Cocos2d游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://z351522453.github.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://z351522453.github.com/category/dai-ma-da-quan.html">代碼大全</a></li>
            <li><a href="http://z351522453.github.com/category/golang.html">Golang</a></li>
            <li><a href="http://z351522453.github.com/category/hadoop.html">hadoop</a></li>
            <li><a href="http://z351522453.github.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://z351522453.github.com/category/jia-che-bao-dian.html">驾车宝典</a></li>
            <li><a href="http://z351522453.github.com/category/jia-gou-shi-zhi-lu.html">架构师之路</a></li>
            <li><a href="http://z351522453.github.com/category/ling-ji-chu-qt-ru-men.html">零基础 QT 入门</a></li>
            <li><a href="http://z351522453.github.com/category/linux.html">Linux</a></li>
            <li><a href="http://z351522453.github.com/category/luayou-xi-kai-fa.html">Lua游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/pyqt-kai-fa.html">PyQt 开发</a></li>
            <li><a href="http://z351522453.github.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-flask.html">深入浅出 Flask</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-mongodb.html">深入浅出 Mongodb</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-redis.html">深入浅出 Redis</a></li>
            <li><a href="http://z351522453.github.com/category/za-xiang.html">杂项</a></li>
            <li><a href="http://z351522453.github.com/category/zai-xue-java.html">再学 JAVA</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>