<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>Python fabric</title>

    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.com/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.com/python-fabric.html" rel="bookmark"
        title="Permalink to Python fabric">Python fabric</a></h3>
    </header>

<h6 class="subheader" title="2016-04-20T13:31:00+08:00">Wed 20 April 2016
</h6>


    <div class="toc">
<ul>
<li><a href="#1">1. 安装</a><ul>
<li><a href="#mingw">借助 MinGW</a></li>
<li><a href="#vs2010">借助 VS2010</a></li>
<li><a href="#microsoft-visual-c-compiler-package-for-python-27">解决 Microsoft Visual C++ Compiler Package for Python 2.7 无效</a></li>
</ul>
</li>
<li><a href="#2-fabric">2. 第一个 fabric 脚本</a></li>
<li><a href="#3">3. 带参数的脚本</a></li>
<li><a href="#4">4. 执行本地操作</a></li>
<li><a href="#5">5. 执行远程操作</a></li>
<li><a href="#6">6. 基于角色的执行任务</a></li>
<li><a href="#7">7. 项目同步工具</a></li>
<li><a href="#8">8. 新风格任务</a><ul>
<li><a href="#81">8.1 经典风格</a></li>
<li><a href="#82">8.2 新风格</a><ul>
<li><a href="#task-default">@task default</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#9-virtualenv">9. 使用 virtualenv</a><ul>
<li><a href="#91-virtualenv">9.1. 调用远程的 virtualenv</a></li>
<li><a href="#92-virtualenv">9.2. 调用本地的 virtualenv</a></li>
</ul>
</li>
<li><a href="#10-python-task">10. 通过 python 来执行 task</a></li>
<li><a href="#11">11. 中文问题</a></li>
<li><a href="#_1">参考文档</a></li>
</ul>
</div>
<p>Python fabric 号称 Python 三神器之一, 可以在本地、远程依次执行一系列 shell 命令、程序等, 比如从代码库更新代码、执行数据迁移脚本、重启服务进程等等, 因此常常被用来自动化远程部署项目, 非常的方便.</p>
<p>当然你要说 <strong>Docker</strong> 更好, 我也同意, 然而有一些 32 位的低配系统, 并不适合用 <strong>Docker</strong>, 更不用说虚拟机了, 这时一个轻量级的 fabric 就能帮你解决部署问题.</p>
<h1 id="1">1. 安装</h1>
<p>虽然 fabric 是支持 pip 来安装的, 但实际操作时, 安装 fabric 的依赖库 pycrypto 会报错, 大概的意思就是编译环境的问题.</p>
<p>这是因为 fabric 涉及了一些系统底层的东西, 凡是安装和操作系统底层密切相关的扩展, 大多都会调用 C 编译器去编译一些系统 DLL, 如果你的系统没有这个编译器, 就会报错&hellip;</p>
<p>有几种解决方法 (<strong>推荐第三种中的第二种</strong>):</p>
<ul>
<li>第一种: 一般这类的扩展都提供 windows 的安装版本(<a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto">msi 或者 exe 执行文件</a>)</li>
<li>第二种: 下载<a href="http://share.weiyun.com/8d44e45a0b9186c3dc03730a65eb643c">源码</a>, 手动使用 <code>python setup.py install --skip-build</code> 编译</li>
<li>第三种: 搭建编译环境, 这里也有三种方式:<ul>
<li>第一种: 借助 mingw32, 具体操作看下面 <code>借助 MinGW</code></li>
<li>第二种: 借助 <a href="http://www.microsoft.com/en-us/download/details.aspx?id=44266">Microsoft Visual C++ Compiler Package for Python 2.7</a>, 这里有可能会出现问题, 详情见下面的 <code>解决 Microsoft Visual C++ Compiler Package for Python 2.7 无效</code></li>
<li>第三种: 借助 VS2010, 这个比较麻烦, 具体操作看下面 <code>借助 VS2010</code></li>
<li>第二种 > 第三种 > 第一种</li>
</ul>
</li>
</ul>
<p>参考文档:<br>
<a href="http://my.oschina.net/zhangdapeng89/blog/54407">http://my.oschina.net/zhangdapeng89/blog/54407</a><br>
<a href="http://www.myexception.cn/windows/414562.html">http://www.myexception.cn/windows/414562.html</a><br>
<a href="http://blog.csdn.net/donger_soft/article/details/44838109">http://blog.csdn.net/donger_soft/article/details/44838109</a><br>
<a href="http://www.2cto.com/os/201506/409745.html">http://www.2cto.com/os/201506/409745.html</a></p>
<h2 id="mingw">借助 MinGW</h2>
<p>首先安装 MinGW, 在 MinGW 的安装目录下找到 bin 的文件夹, 找到 mingw32-make.exe, 复制一份更名为 make.exe;</p>
<p>把 MinGW 的路径添加到环境变量 path 中, 比如我把 MinGW 安装到 D:\MinGW\ 中, 就把 D:\MinGW\bin 添加到 path 中;</p>
<p>打开命令行窗口, 在命令行窗口中进入到要安装代码的目录下, 输入如下命令就可以安装了:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>python setup.py build --compiler=mingw32 install
</pre></div>


<p><br></p>
<h2 id="vs2010">借助 VS2010</h2>
<p>去下载安装 VS2010 (08版貌似也行, 不过没必要用旧版, 指不定哪个库又无法编译)</p>
<p>配置系统环境变量 <strong>VS90COMNTOOLS</strong> 指向 <code>%VS你的版本COMNTOOLS%</code></p>
<ul>
<li>如果你安装的是 2012 版 <code>%VS110COMNTOOLS%</code></li>
<li>如果你安装的是 2013 版 <code>%VS120COMNTOOLS%</code></li>
</ul>
<p>或者更暴力, 在 python 安装路径 ~\Lib\distutils 目录下有个 <strong>msvc9compiler.py</strong>(这个就是为什么要配 &ldquo;VS90COMNTOOLS&rdquo; 的原因, 因为人家文件名都告诉你了是 Microsoft vc 9 compiler, 代码都写死了要 vc9 的 comntools).<br>
找到 243 行:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>toolskey = &quot;VS%0.f0COMNTOOLS&quot; % version
直接改为
toolskey = &quot;VS你的版本COMNTOOLS&quot;
</pre></div>


<p><br>
然后该重启的重启, clean 一下之前安装 Python 扩展失败的残留文件, 然后该 pip 的 pip 吧&hellip;</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>pip install fabric
</pre></div>


<p><br></p>
<h2 id="microsoft-visual-c-compiler-package-for-python-27">解决 Microsoft Visual C++ Compiler Package for Python 2.7 无效</h2>
<p><strong>错误描述:</strong><br>
明明从官网下载并安装了 Microsoft Visual C++ Compiler Package for Python 2.7, 且配置了环境变量 path, 但还是报编译错误.</p>
<p><strong>错误原因:</strong><br>
报这个错误的原因是 Python 的 distutils 模块中的 msvc9compiler.py 并不从环境变量指定的路径中寻找 &lsquo;vcvarsall.bat&rsquo;, 而是通过注册表来寻找, 然而, 不知为什么编译器安装过程没有配置注册表.</p>
<p><strong>解决办法:</strong><br>
只要手工把注册表配置好, 就可以了.</p>
<ul>
<li>开注册表编辑器<ul>
<li>run regedit</li>
</ul>
</li>
<li>配置<ul>
<li>如果你安装的 Python 是 32 位的, 则创建如下项: <code>HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\9.0\Setup\VC</code></li>
<li>如果你安装的 Python 是 64 位的, 则创建如下项: <code>HKEY_CURRENT_USER\Software\Wow6432Node\Microsoft\VisualStudio\9.0\Setup\VC</code></li>
</ul>
</li>
<li>并在此项下新建字符串值<ul>
<li>名称:productdir</li>
<li>数据:vcvarsall.bat所在路径</li>
<li>注意:路径中不包含最后的反斜杠.</li>
</ul>
</li>
</ul>
<h1 id="2-fabric">2. 第一个 fabric 脚本</h1>
<p>我这里使用的是 virtualenv 环境, 安装 pycrypto 使用的是 <strong>第一种</strong> 方法 (即直接下载 exe 安装的), 所以需要拷贝系统 python ~\Lib\site-packages 下的 <strong>Crypto</strong> 文件夹到 virtualenv 中, 然后 cmd 进入虚拟环境(即执行 activate), 安装 fabric: <code>pip install fabric</code></p>
<p>安装好 fabric 后, 新建一个 py 脚本: <strong>fabfile.py</strong></p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>():
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;Hello world!&quot;</span>)
</pre></div>


<p><br>
命令行执行:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>(venv) fab hello
Hello world!

Done.
</pre></div>


<p><br>
<strong>fabfile</strong> 是 fabric 默认的脚本名, 可以不用 <strong>fabfile</strong>, 但是在执行时就需要通过 <strong>-f</strong> 指定文件名了, 例如把上面的 fabfile.py 改为 <strong>test.py</strong></p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>(venv) fab hello

Fatal error: Couldn&#39;t find any fabfiles!

Remember that -f can be used to specify fabfile path, and use -h for help.

Aborting.

(venv) fab -f test.py hello
Hello world!

Done.
</pre></div>


<p><br></p>
<blockquote>
<p>找不到 fab 命令<br>这种情况只会出现在 python 真实环境, 因为有可能没有权限改环境变量,
fab.exe 在 python 安装目录的 Scripts 目录, 要把该路径加入到环境变量 Path 中.</p>
<p>执行 fab 提示找不到 fabfiles<br>
原因: 跟 python 的 PYTHONPATH 有关系, 如果 fabfile.py 没有放在 PYTHONPATH 中, 会提示找不到.<br>
解决:使用 -f 指定文件</p>
</blockquote>
<h1 id="3">3. 带参数的脚本</h1>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">hello</span>(name, value):
    <span style="color: #8B008B; font-weight: bold">print</span>(<span style="color: #CD5555">&quot;%s = %s!&quot;</span> % (name, value))
</pre></div>


<p><br>
执行:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>(venv) fab hello:name=age, value=20
age = 20!

Done.
(venv) fab hello:age, 20
age = 20!

Done.
</pre></div>


<p><br></p>
<h1 id="4">4. 执行本地操作</h1>
<p>在 fabric 中:
caputure=False 时,本地 subprocess 的可通过全局输出控制,output.stdout 等,此时返回为空。
caputure=True 时,命令 stdout 作为类 string 对象返回,同 run/sudo 一样,返回值有 return_code,stderr,failed 和 succeeded 属性。</p>
<ul>
<li>local: 用来执行本地命令<ul>
<li>可选参数 capture 布尔型<ul>
<li>True, 标准输出和错误作为一个对象返回, 通过 <code>print result.__dict__</code> 发现该对象有下面这些可用属性:<ul>
<li>succeeded</li>
<li>failed</li>
<li>return_code</li>
<li>command</li>
<li>stderr</li>
<li>stdout</li>
<li>real_command</li>
</ul>
</li>
<li>False, 标准输出和错误直接显示在终端, 和 True 时一样, 也有一个返回值对象, 但 stderr 和  stdout 始终为空</li>
</ul>
</li>
</ul>
</li>
<li>lcd: 本地的上下文管理, 简单的理解就是本地执行 cd 命令, 需要配合 with 语句<ul>
<li><strong>注意</strong>: 由于 windows 的尿性, <strong>cd</strong> 命令不能进行根目录间 (C 盘、D 盘等) 的切换</li>
</ul>
</li>
</ul>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> local, lcd

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dirCurrent</span>():
    <span style="color: #8B008B; font-weight: bold">with</span> lcd(<span style="color: #CD5555">&#39;./Current&#39;</span>):
        local(<span style="color: #CD5555">&#39;dir&#39;</span>)
</pre></div>


<p><br>
结果:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>(venv) fab dirCurrent
[localhost] local: cd ./Current
[localhost] local: dir
E:\venv\Current 的目录

2016/04/20  16:47    &lt;DIR&gt;          .
2016/04/20  16:47    &lt;DIR&gt;          ..
2016/04/14  20:17                12 .gitignore
2016/04/19  21:02             3,907 MysqlHelper.py
2016/04/19  21:02             3,594 MysqlHelper.pyc

Done.
</pre></div>


<p><br>
我们可以通过 fabric 完成 Git 版本库的日常维护, 例如:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> local, lcd

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dailyGit</span>():
    <span style="color: #8B008B; font-weight: bold">with</span> lcd(<span style="color: #CD5555">&#39;./iMessageCracker&#39;</span>):
        local(<span style="color: #CD5555">&#39;git add .&#39;</span>)
        local(<span style="color: #CD5555">&#39;git commit -m &quot;daily update&quot;&#39;</span>)
</pre></div>


<p><br></p>
<h1 id="5">5. 执行远程操作</h1>
<p>在 fabric 中:</p>
<ul>
<li>run: 用来执行远程命令<ul>
<li>在 local 命令中, 我们通过可选参数 capture 来控制返回值的处理方式, 但在 run 命令中, 没有 capture 参数, run 在终端直接显示返回信息, 并产生一个返回值对象, 即 run 包含了 capture 的真/假两种情况</li>
<li>如果需要编程检测远程程序的标准错误流 (利用函数返回值的 stderr 属性), 可以设置 <code>combine_stderr=False</code>, 这样当你远程调用一个程序产生标准错误流时, run 返回值的 stderr 属性就会保存这些信息, 虽然这么做会使终端输出很混乱, 但是这是单独获取标准错误流的唯一方式</li>
</ul>
</li>
<li>sudo: 用来执行远程 sudo 命令</li>
<li>cd: 远程的上下文管理, 简单的理解就是远程执行 cd 命令, 需要配合 with 语句</li>
<li>env: 环境变量<ul>
<li>env.hosts, 远程主机列表,<ul>
<li>格式: user name @ ip : port</li>
<li>user name 及 port 可忽略, port 默认为 22</li>
</ul>
</li>
<li>env.user, 远程主机用户名, 除非 env.hosts 显示的指定了 user name, 否则都用 env.user 配置的用户名</li>
<li>env.password, 如果指定, 则远程主机列表里的主机都使用这个密码</li>
<li>env.passwords, 密码列表, key 是 host, value 是密码<ul>
<li>要使 env.passwords 生效, host 的端口号一定要显式写出来, 即使是使用的默认 22 端口</li>
</ul>
</li>
</ul>
</li>
<li>get: 下载文件 (前提是有待处理文件的权限)<ul>
<li>不能操作文件夹, 可以打包后下载</li>
</ul>
</li>
<li>put: 上传文件 (前提是有待处理文件的权限)<ul>
<li>不能操作文件夹, 可以打包后上传</li>
</ul>
</li>
<li>prefix: 命令上下文管理, 需要配合 with 语句<ul>
<li>处在 prefix 上下文环境下的命令, 都会加上 prefix 里指定的前缀</li>
</ul>
</li>
</ul>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #228B22"># prefix 举例</span>

<span style="color: #8B008B; font-weight: bold">with</span> prefix(<span style="color: #CD5555">&#39;workon myvenv&#39;</span>):
        run(<span style="color: #CD5555">&#39;ls&#39;</span>)
</pre></div>


<p><br>
相当于执行命令: <code>workon myvenv &amp;&amp; ls</code></p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #228B22"># 远程操作举例</span>

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> local, cd, run, env

env.hosts = [<span style="color: #CD5555">&#39;user name@ip:port&#39;</span>,]
env.passwords = {
    <span style="color: #CD5555">&#39;user name@ip:port&#39;</span>: <span style="color: #CD5555">&#39;xxx&#39;</span>
}

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">remoteGit</span>():
    <span style="color: #8B008B; font-weight: bold">with</span> cd(<span style="color: #CD5555">&#39;/usr/project/&#39;</span>):
        run(<span style="color: #CD5555">&#39;git --version&#39;</span>)
</pre></div>


<p><br>
执行结果:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>[user name@10.0.3.57] Executing task &#39;remoteGit&#39;
[user name@10.0.3.57] run: git --version
[user name@10.0.3.57] out: git version 1.7.9.5
[user name@10.0.3.57] out:

Done.
Disconnecting from user name@10.0.3.57... done.
</pre></div>


<p><br></p>
<h1 id="6">6. 基于角色的执行任务</h1>
<p>在 <code>5. 执行远程操作</code> 的例子中, fabric 会将任务应用到所有 env.hosts 中指定的 hosts.</p>
<p>通过 <code>env.roledefs</code> 可以指定一个任务只运行到某个或某几个 hosts 上.</p>
<p>env.roledefs 的是一个字典, key 为 role 名 (自定义就好), value 是 host 列表 (如: [&lsquo;10.1.6.186&rsquo;, &lsquo;10.1.6.159&rsquo;])</p>
<p>env.passwords 的 key 来自 env.roledefs 的 value.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> local, cd, run, env

env.roledefs = {<span style="color: #CD5555">&#39;web1&#39;</span>: [host <span style="color: #a61717; background-color: #e3d2d2">列表</span>], <span style="color: #CD5555">&#39;web2&#39;</span>: [host <span style="color: #a61717; background-color: #e3d2d2">列表</span>]}
env.passwords = {
    <span style="color: #CD5555">&#39;user name@ip:port&#39;</span>: <span style="color: #CD5555">&#39;xxx&#39;</span>
}

<span style="color: #707a7c">@roles</span>(<span style="color: #CD5555">&#39;web1&#39;</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">remoteGit</span>():
    <span style="color: #8B008B; font-weight: bold">with</span> cd(<span style="color: #CD5555">&#39;/usr/project/&#39;</span>):
        run(<span style="color: #CD5555">&#39;git --version&#39;</span>)
</pre></div>


<p><br>
上面的 remoteGit 就只会被运行在指定的 <strong>web1</strong> 上了.</p>
<h1 id="7">7. 项目同步工具</h1>
<p><code>from fabric.contrib.project import rsync_project</code> 是个很好的工具, 不过只有 linux 下能用&hellip; 因为 windows 上没有 <strong>rsync</strong>.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.contrib.project</span> <span style="color: #8B008B; font-weight: bold">import</span> rsync_project

rsync_project(local_dir = <span style="color: #CD5555">&#39;xxx&#39;</span>, remote_dir = <span style="color: #CD5555">&#39;/home/user name/xxx&#39;</span>, exclude = <span style="color: #CD5555">&#39;.git&#39;</span>)
</pre></div>


<p><br>
与之功能相似的还有 <code>fabric.contrib.project.upload_project</code></p>
<h1 id="8">8. 新风格任务</h1>
<p>在 fabric 1.1 之后, fabric 引进两种不同的任务定义方法: 新风格和经典风格</p>
<p>它们在判断 fabfile 中什么对象才是 fabric 任务时方式不同:</p>
<ul>
<li>__经典风格__认为 fabfile 中的所有 public 可调用对象 (包括 functions, classes 等等) 为任务, 而且仅仅是 fabfile 中的对象才行, fabfile 中 import 的其他模块都不算任务(但通过 from 引入的算任务)</li>
<li>__新风格__认为 Task (新风格引用的任务基类) 的实例或者它的子类为任务, 并且可以递归 import 模块中的任务, 而且支持不同的命名空间(__init__.py)</li>
</ul>
<p>这两种定义方式是__相互排斥__的, 如果 fabric 发现任何新风格的任务对象, 它就会认为你已经使用这种新风格的任务声明, 而不会考虑任何没有 <strong>Task</strong> 声明的对象, 如果没有新风格任务发现, 它会使用默认经典风格.</p>
<h2 id="81">8.1 经典风格</h2>
<p>在之前, 我们使用的都是经典任务风格, 是的, 那就是普通的 python 函数, 当没有新风格任务发现时, fabric 默认都是经典任务, 注意一下情况:</p>
<ul>
<li>函数名以 __ 下划线开头, python 认为是 private 的函数, fabric认为不是任务</li>
<li>函数中没有用到 fabric 自身 api, fabric认为不是任务</li>
<li>fabric 经典风格不能递归 import 模块中的任务<ul>
<li>如果是通过 <strong>from</strong> 引入, 则可算任务</li>
</ul>
</li>
</ul>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">urllib</span> <span style="color: #8B008B; font-weight: bold">import</span> urlopen
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> run
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">webservice_read</span>():
    objects = urlopen(<span style="color: #CD5555">&#39;http://my/web/service/?foo=bar&#39;</span>).read().split()
    <span style="color: #8B008B; font-weight: bold">print</span>(objects)
</pre></div>


<p><br>
fab 认为 urlopen 也是一个任务.</p>
<h2 id="82">8.2 新风格</h2>
<p>新风格任务的出现是为了对面向对象特性及命名空间提供支持。</p>
<p>通过引进 Task, 有两种方式来定义新任务。</p>
<ul>
<li>定义常规的模块级别的函数并带有装饰器 <strong>@task</strong>, 这会直接将该函数转化为 Task 子类, 该函数名会被作为任务名, __@task__包含下面这些参数:<ul>
<li>task_class: Task 的子类, 被用来装饰函数, 默认是 WrappedCallableTask</li>
<li>aliases: 一个可迭代的 string names, 被用来作为该函数的别名</li>
<li>alias: 跟 aliases 类似, 但只有一个 string 值而不是可迭代对象, 如果 aliases 同时存在, 前者优先</li>
<li>default: 布尔值, 指定被包装的函数为模块的默认任务(在只有 fabfile.py 一个文件时, 这个参数是没有意义的), 详情见下面的 <code>@task default</code></li>
</ul>
</li>
<li>继承 Task 类, 定义 run 方法, 然后要在模块级别进行实例化, name 属性会被作为任务名</li>
</ul>
<blockquote>
<p>注意, 如果有多个装饰器时, @task 必须做为第一个, 否则会出现一些奇怪的问题</p>
</blockquote>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #228B22"># 通过装饰器定义</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> task, run

<span style="color: #707a7c">@task</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">mytask</span>(): <span style="color: #228B22"># 任务名为 mytask</span>
    run(<span style="color: #CD5555">&#39;a command&#39;</span>)

<span style="color: #228B22"># 通过继承 Task 类</span>
<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">MyTask</span>(Task):
    name = <span style="color: #CD5555">&quot;deploy&quot;</span> <span style="color: #228B22"># 任务名为 deploy</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run</span>(<span style="color: #658b00">self</span>):
        run(<span style="color: #CD5555">&#39;git clone foo&#39;</span>)
        sudo(<span style="color: #CD5555">&#39;service apache2 restart&#39;</span>)

instance = MyTask()
</pre></div>


<p><br>
也可以结合这两种定义方式, 例如下面这个例子:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> task
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.tasks</span> <span style="color: #8B008B; font-weight: bold">import</span> Task

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">CustomTask</span>(Task):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, func, myarg, *args, **kwargs):
        <span style="color: #658b00">super</span>(CustomTask, <span style="color: #658b00">self</span>).__init__(*args, **kwargs)
        <span style="color: #658b00">self</span>.func = func
        <span style="color: #658b00">self</span>.myarg = myarg

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run</span>(<span style="color: #658b00">self</span>, *args, **kwargs):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.func(*args, **kwargs)

<span style="color: #707a7c">@task</span>(task_class = CustomTask, myarg = <span style="color: #CD5555">&#39;value&#39;</span>, alias = <span style="color: #CD5555">&#39;at&#39;</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">actual_task</span>():
    <span style="color: #8B008B; font-weight: bold">pass</span>
</pre></div>


<p><br>
这相当于生成一个新任务:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>task_obj = CustomTask(actual_task, myarg = <span style="color: #CD5555">&#39;value&#39;</span>)
</pre></div>


<p><br>
当然, myarg 参数可以在运行任务时指定:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>fab actual_task:myarg=value
</pre></div>


<p><br>
这种组合的方式, 在你想用使用 class metaprogramming or similar techniques 时会有用.</p>
<h3 id="task-default">@task default</h3>
<p>新建一个文件 deploy.py:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> task

<span style="color: #707a7c">@task</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">migrate</span>():
    <span style="color: #8B008B; font-weight: bold">pass</span>

<span style="color: #707a7c">@task</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">full_deploy</span>():
    migrate()
</pre></div>


<p><br>
然后在 fabfile.py 中 import deploy, 再通过命令行 <code>fab -list</code> 查看当前可用任务:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>Available commands:

    deploy.full_deploy
    deploy.migrate
</pre></div>


<p><br>
现在我们把 full_deploy 设为默认任务, 看看有什么效果:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> task

<span style="color: #707a7c">@task</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">migrate</span>():
    <span style="color: #8B008B; font-weight: bold">pass</span>

<span style="color: #707a7c">@task</span>(default = <span style="color: #658b00">True</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">full_deploy</span>():
    migrate()
</pre></div>


<p><br>
再次通过命令行 <code>fab -list</code> 查看当前可用任务:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>Available commands:

    deploy
    deploy.full_deploy
    deploy.migrate
</pre></div>


<p><br>
可以看到多了一个 deploy 任务, 它就是 deploy.py 的默认任务</p>
<h1 id="9-virtualenv">9. 使用 virtualenv</h1>
<p>想通过 <code>run('source ./venv/bin/activate')</code> 去进入 virtualenv 是不行的.</p>
<h2 id="91-virtualenv">9.1. 调用远程的 virtualenv</h2>
<p>官方提供的解决方案是使用 <strong>prefix</strong>, prefix 与 cd 类似, 是远程命令:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">with</span> prefix(<span style="color: #CD5555">&#39;source ~/venv/bin/activate&#39;</span>):
    run(<span style="color: #CD5555">&#39;./manage.py syncdb&#39;</span>)
</pre></div>


<p><br>
或者, 可以使用第三方扩展 <strong>fabric-virtualenv</strong>.</p>
<p>直接使用 <code>pip install fabric-virtualenv</code> 即可安装, 使用起来也很简单:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabvenv</span> <span style="color: #8B008B; font-weight: bold">import</span> virtualenv

<span style="color: #8B008B; font-weight: bold">with</span> virtualenv(<span style="color: #CD5555">&#39;/home/venv&#39;</span>):
    run(<span style="color: #CD5555">&#39;pip freeze&#39;</span>)
</pre></div>


<p><br>
好了, 根据结果看看是不是输出了对应 virtualenv 下的扩展包.</p>
<p><strong>注意:</strong> fabric-virtualenv 内部使用的也是 prefix , 所以也只支持远程操作, 不是本地的.</p>
<h2 id="92-virtualenv">9.2. 调用本地的 virtualenv</h2>
<p>因为 prefix 是远程命令, 所以如果想添加本地支持的话, 就得自己来模拟了&hellip;</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">posixpath</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">contextlib</span> <span style="color: #8B008B; font-weight: bold">import</span> contextmanager
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>

<span style="color: #707a7c">@contextmanager</span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">lvirtualenv</span>(path):
    activate = posixpath.join(path, <span style="color: #CD5555">&#39;bin/activate&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> os.path.exists(activate):
        <span style="color: #8B008B; font-weight: bold">raise</span> <span style="color: #008b45; font-weight: bold">OSError</span>(<span style="color: #CD5555">&quot;Cannot activate virtualenv %s&quot;</span> % path)
    activate = <span style="color: #CD5555">&#39;. %s&#39;</span> % activate

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">local_call</span>(command):
        <span style="color: #8B008B; font-weight: bold">return</span> local(<span style="color: #CD5555">&#39;%s &amp;&amp; %s&#39;</span> % (activate, command))

    <span style="color: #8B008B; font-weight: bold">yield</span> local_call

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test</span>():
    <span style="color: #8B008B; font-weight: bold">with</span> lvirtualenv(<span style="color: #CD5555">&#39;/home/apuser/PyMC/pymc_venv&#39;</span>) <span style="color: #8B008B; font-weight: bold">as</span> local:
        local(<span style="color: #CD5555">&#39;pwd&#39;</span>)
</pre></div>


<p><br>
这样我们最终的输出结果就是:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>[localhost] local: . /home/apuser/PyMC/pymc_venv/bin/activate &amp;&amp; <span style="color: #658b00">pwd</span>
/home/apuser/PyMC/iMessageCracker/Deploy
</pre></div>


<p><br></p>
<h1 id="10-python-task">10. 通过 python 来执行 task</h1>
<p>在之前, 我们通过 <strong>fab</strong> 工具来执行 task.</p>
<p>在 Fabric &gt;=1.3 中, 可以使用 execute 来在 python 中运行一个 task, 就像下面这样:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fabric.api</span> <span style="color: #8B008B; font-weight: bold">import</span> local, execute

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_for_execute</span>():
    local(<span style="color: #CD5555">&#39;pip freeze&#39;</span>)

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    execute(test_for_execute)
</pre></div>


<p><br>
不仅如此, execute 还能接受 task 的返回值, 只要在 task 中 return 就好了, execute 本身返回一个字典, task 的返回值将做为这个字典的项.</p>
<p>基于 fabric 编程时, 如果想知道命令的执行结果:</p>
<ul>
<li>local 命令需要设置 capture 参数</li>
<li>run 命令直接使用返回值就可以了</li>
</ul>
<h1 id="11">11. 中文问题</h1>
<p>使用 fabric 获取的标准输出流中的中文是被 gbk 编码的, 如果你最终存放结果的&rdquo;地方&rdquo;不支持 gbk 显示, 就要用 <code>xxx.decode('gbk')</code> 进行解码&hellip;</p>
<blockquote>
<p>你可以通过 python 第三方工具包 chardet 来判断字符串编码方式: <code>chardet.detect(xxx)</code></p>
</blockquote>
<h1 id="_1">参考文档</h1>
<p><a href="http://blog.csdn.net/raptor/article/details/50397658">http://blog.csdn.net/raptor/article/details/50397658</a><br>
<a href="http://paperplane.ruhoh.com/documentation/fabric/">http://paperplane.ruhoh.com/documentation/fabric/</a><br>
<a href="http://paperplane.ruhoh.com/fabric/fabric-api/">http://paperplane.ruhoh.com/fabric/fabric-api/</a><br>
<a href="http://docs.fabfile.org/en/latest/tutorial.html">http://docs.fabfile.org/en/latest/tutorial.html</a><br>
<a href="http://ruiaylin.github.io/2014/11/24/fabric/">http://ruiaylin.github.io/2014/11/24/fabric/</a><br>
<a href="http://wklken.me/posts/2013/03/25/python-tool-fabric.html#_4">http://wklken.me/posts/2013/03/25/python-tool-fabric.html#_4</a></p>
<p class="subheader">Category: <a href="http://blog.smallcpp.com/category/python.html">Python</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="python-fabric" data-title="Python fabric" data-url="http://blog.smallcpp.com/python-fabric.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.com/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/category/c11.html">C++11</a></li>
            <li><a href="http://blog.smallcpp.com/category/cocos2d.html">Cocos2d</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-java-ji-chu.html">大数据 Java 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-linux-ji-chu.html">大数据 Linux 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-mongodb-ji-chu.html">大数据 Mongodb 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-redis-ji-chu.html">大数据 Redis 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.com/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.com/category/java.html">JAVA</a></li>
            <li><a href="http://blog.smallcpp.com/category/lua.html">Lua</a></li>
            <li><a href="http://blog.smallcpp.com/category/pyqt.html">PyQt</a></li>
            <li><a href="http://blog.smallcpp.com/category/python.html">Python</a></li>
            <li><a href="http://blog.smallcpp.com/category/qt.html">QT</a></li>
            <li><a href="http://blog.smallcpp.com/category/ruan-jian-she-ji.html">软件设计</a></li>
            <li><a href="http://blog.smallcpp.com/category/za-xiang.html">杂项</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>