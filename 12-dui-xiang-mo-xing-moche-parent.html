<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>12、对象模型(moc和parent)</title>

    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.com/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.com/12-dui-xiang-mo-xing-moche-parent.html" rel="bookmark"
        title="Permalink to 12、对象模型(moc和parent)">12、对象模型(moc和parent)</a></h3>
    </header>

<h6 class="subheader" title="2015-03-08T14:02:00+08:00">Sun 08 March 2015
</h6>


    <p>转自: <a href="http://www.devbean.net/">http://www.devbean.net/</a></p>
<p>在使用标准 C++ 编译器编译 Qt 源程序之前，Qt 先使用一个叫做 moc（Meta Object Compiler，元对象编译器）的工具，先对 Qt 源代码进行一次预处理（<em>注意，这个预处理与标准 C++ 的预处理有所不同。Qt 的 moc 预处理发生在标准 C++ 预处理器工作之前，并且 Qt 的 moc 预处理不是递归的。</em>），生成标准 C++ 源代码，然后再使用标准 C++ 编译器进行编译。如果你曾经为信号函数这样的语法感到奇怪（现在我们已经编译过一些 Qt 程序，你应当注意到了，信号函数是不需要编写实现代码的，那怎么可以通过标准 C++ 的编译呢？），这其实就是 moc 进行了处理之后的效果。</p>
<p>Qt 使用 moc，为标准 C++ 增加了一些特性：</p>
<p>1.信号槽机制，用于解决对象之间的通讯，这个我们已经了解过了，可以认为是 Qt 最明显的特性之一；</p>
<p>2.可查询，并且可设计的对象属性；</p>
<p>3.强大的事件机制以及事件过滤器；</p>
<p>4.基于上下文的字符串翻译机制（国际化），也就是 tr() 函数，我们简单地介绍过；</p>
<p>5.复杂的定时器实现，用于在事件驱动的 GUI 中嵌入能够精确控制的任务集成；</p>
<p>6.层次化的可查询的对象树，提供一种自然的方式管理对象关系。</p>
<p>7.智能指针（QPointer），在对象析构之后自动设为 0，防止野指针；</p>
<p>8.能够跨越库边界的动态转换机制。</p>
<p>通过继承<code>QObject</code>类，我们可以很方便地获得这些特性。当然，这些特性都是由 moc 帮助我们实现的。moc 其实实现的是一个叫做元对象系统（meta-object system）的机制。正如上面所说，这是一个标准 C++ 的扩展，使得标准 C++ 更适合于进行 GUI 编程。虽然利用模板可以达到类似的效果，但是 Qt 没有选择使用模板。按照 Qt 官方的说法，模板虽然是内置语言特性，但是其语法实在是复杂，并且由于 GUI 是动态的，利用静态的模板机制有时候很难处理。而自己使用 moc 生成代码更为灵活，虽然效率有些降低（一个信号槽的调用大约相当于四个模板函数调用），不过在现代计算机上，这点性能损耗实在是可以忽略。</p>
<p>在本节中，我们将主要介绍 Qt 的对象树。
在 Qt 中, 很多控件及类的构造函数有一个 parent 指针, 这个指针是什么?
现在我们就来解释这个 parent 到底是干什么的。</p>
<p><code>QObject</code>是以对象树的形式组织起来的。当你创建一个<code>QObject</code>对象时，会看到<code>QObject</code>的构造函数接收一个<code>QObject</code>指针作为参数，这个参数就是 parent，也就是父对象指针。这相当于，在创建<code>QObject</code>对象时，可以提供一个其父对象，我们创建的这个<code>QObject</code>对象会自动添加到其父对象的<code>children()</code>列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（<strong>注意，这里的父对象并不是继承意义上的父类！</strong>）这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个<code>QShortcut</code>（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p>
<p><code>QWidget</code>是能够在屏幕上显示的一切组件的父类。<code>QWidget</code>继承自<code>QObject</code>，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p>
<p>当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p>
<p>我们可以使用<code>QObject::dumpObjectTree()</code>和<code>QObject::dumpObjectInfo()</code>这两个函数进行这方面的调试。</p>
<p>Qt 引入对象树的概念，在一定程度上解决了内存问题: 如果指针对象有父对象时, 可以不用显式释放内存, 我们需要显式释放的是那些没有父对象的孤立的指针.</p>
<p>当一个<code>QObject</code>对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。Qt 保证的是，任何对象树中的 <code>QObject</code>对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的<code>children()</code>列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有<code>QObject</code>会被 delete 两次，这是由析构顺序决定的。</p>
<p>如果<code>QObject</code>在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：</p>
<div class="codehilite" style="background: #000000"><pre style="line-height: 125%"><span></span>&lt;span style=&quot;color: #000000;&quot;&gt;{
    QWidget window;
    QPushButton quit(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;Quit&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;, &amp;&lt;span style=&quot;color: #000000;&quot;&gt;window);
}&lt;/span&gt;
</pre></div>


<p>作为父组件的 window 和作为子组件的 quit 都是<code>QObject</code>的子类（事实上，它们都是<code>QWidget</code>的子类，而<code>QWidget</code>是<code>QObject</code>的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++ （ISO/IEC 14882:2003）要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</p>
<p>但是，如果我们使用下面的代码：</p>
<div class="codehilite" style="background: #000000"><pre style="line-height: 125%"><span></span>&lt;span style=&quot;color: #000000;&quot;&gt;{
    QPushButton quit(&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;Quit&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;);
    QWidget window;

    quit.setParent(&lt;/span&gt;&amp;&lt;span style=&quot;color: #000000;&quot;&gt;window);
}&lt;/span&gt;
</pre></div>


<p>情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。</p>
<p>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，<strong>尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。</strong>
?</p>
<p class="subheader">Category: <a href="http://blog.smallcpp.com/category/qt.html">QT</a>

</p>




<!--      -->

    <!-- 多说评论框 start -->
    <h4>Comments !</h4>
    <div class="ds-thread" data-thread-key="12-dui-xiang-mo-xing-moche-parent" data-title="12、对象模型(moc和parent)" data-url="http://blog.smallcpp.com/12-dui-xiang-mo-xing-moche-parent.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"smallcpp"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
    </script>
    <!-- 多说公共JS代码 end -->
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.com/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/category/c11.html">C++11</a></li>
            <li><a href="http://blog.smallcpp.com/category/cocos2d.html">Cocos2d</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-java-ji-chu.html">大数据 Java 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-linux-ji-chu.html">大数据 Linux 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-mongodb-ji-chu.html">大数据 Mongodb 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju-redis-ji-chu.html">大数据 Redis 基础</a></li>
            <li><a href="http://blog.smallcpp.com/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.com/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.com/category/java.html">JAVA</a></li>
            <li><a href="http://blog.smallcpp.com/category/lua.html">Lua</a></li>
            <li><a href="http://blog.smallcpp.com/category/pyqt.html">PyQt</a></li>
            <li><a href="http://blog.smallcpp.com/category/python.html">Python</a></li>
            <li><a href="http://blog.smallcpp.com/category/qt.html">QT</a></li>
            <li><a href="http://blog.smallcpp.com/category/ruan-jian-she-ji.html">软件设计</a></li>
            <li><a href="http://blog.smallcpp.com/category/za-xiang.html">杂项</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>