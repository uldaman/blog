<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>14、PyQt 线程使用</title>

    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/pygments.css" />	
    <script src="http://z351522453.github.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://z351522453.github.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://z351522453.github.com/14-pyqt-xian-cheng-shi-yong.html" rel="bookmark"
        title="Permalink to 14、PyQt 线程使用">14、PyQt 线程使用</a></h3>
    </header>

<h6 class="subheader" title="2016-05-16T20:40:00+08:00">周一 16 五月 2016
</h6>


    <p>由于 Python 的线程历史性原因, 所以在 PyQt 中还是推荐使用 Qt 的线程机制.</p>
<div class="toc">
<ul>
<li><a href="#qthread">初识 QThread</a></li>
<li><a href="#_1">线程间通信</a></li>
<li><a href="#qt">Qt 的线程同步</a><ul>
<li><a href="#_2">可用的类</a></li>
<li><a href="#qmutex-qreadwriterlock">QMutex 与 QReadWriterLock</a></li>
<li><a href="#qsemaphore">QSemaphore</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="qthread">初识 QThread</h1>
<p>Qt 使用 <code>QThread</code> 来管理线程, 首先我们要从 QThread 继承一个子类, 并重写它的 <code>run()</code> 方法, 我们可以认为, run() 方法就是线程需要执行的代码, 然后在需要的时候, 调用 QThread::start() 方法启动一个线程.
最后, 还需要将 <code>QThread.deleteLater()</code> 方法与 <code>QThread.finished()</code> 信号连接起来, 以便当线程完成时, 系统可以帮我们清除线程实例.</p>
<p>例如:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">WorkThread</span>(QThread):
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__int__</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>finished<span style="color: #666666">.</span>connect(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>deleteLater)
        <span style="color: #AA22FF">super</span>(WorkThread, <span style="color: #AA22FF">self</span>)<span style="color: #666666">.</span>__init__()

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">run</span>(<span style="color: #AA22FF">self</span>):
        time<span style="color: #666666">.</span>sleep(<span style="color: #666666">10</span>)

workThread <span style="color: #666666">=</span> WorkThread()
workThread<span style="color: #666666">.</span>start()
</pre></div>


<p><br>
需要注意, 如果你在一个类的方法里 start 一个线程, 你需要将线程实例申明为类的属性, 否则, 当你调用完这个 start 线程的类方法后, 由于方法退出, 局部的线程实例被销毁, 就会报错: <code>QThread: Destroyed while thread is still running</code>.</p>
<p>例如下面这样就会报错:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">word_start</span>(<span style="color: #AA22FF">self</span>):
    workThread <span style="color: #666666">=</span> WorkThread()
    workThread<span style="color: #666666">.</span>start()
</pre></div>


<p><br>
要改成:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">word_start</span>(<span style="color: #AA22FF">self</span>):
    <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>workThread <span style="color: #666666">=</span> WorkThread()
    <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>workThread<span style="color: #666666">.</span>start()
</pre></div>


<p><br></p>
<h1 id="_1">线程间通信</h1>
<p>在 Qt 中, 可以很方便的利用信号槽的机制在多线程间进行通信:</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">PyQt4.QtCore</span> <span style="color: #AA22FF; font-weight: bold">import</span> pyqtSignal

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">WorkThread</span>(QThread):
    sin_out <span style="color: #666666">=</span> pyqtSignal()  <span style="color: #008800; font-style: italic"># 定义一个信号</span>

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__int__</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>finished<span style="color: #666666">.</span>connect(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>deleteLater)
        <span style="color: #AA22FF">super</span>(WorkThread, <span style="color: #AA22FF">self</span>)<span style="color: #666666">.</span>__init__()

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">run</span>(<span style="color: #AA22FF">self</span>):
        time<span style="color: #666666">.</span>sleep(<span style="color: #666666">10</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>sin_out<span style="color: #666666">.</span>emit()  <span style="color: #008800; font-style: italic"># 发射信号</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">on_output</span>():
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">u&#39;线程结束&#39;</span>

workThread <span style="color: #666666">=</span> WorkThread()
workThread<span style="color: #666666">.</span>sin_out<span style="color: #666666">.</span>connect(on_output)  <span style="color: #008800; font-style: italic"># 连接信号槽</span>
workThread<span style="color: #666666">.</span>start()
</pre></div>


<p><br></p>
<h1 id="qt">Qt 的线程同步</h1>
<h3 id="_2">可用的类</h3>
<p>Qt 提供以下几个类来保证线程同步问题:</p>
<ul>
<li><strong>QMutex</strong> 提供相互排斥的锁, 或互斥量<ul>
<li><strong>QMutexLocker</strong> 是一个便利类, 它可以自动对 QMutex 加锁与解锁</li>
</ul>
</li>
<li><strong>QReadWriterLock</strong> 提供了一个可以同时读/写操作的锁<ul>
<li><strong>QWriteLocker</strong> 与 <strong>QReadLocker</strong> 是便利类, 它们自动对 <strong>QReadWriteLock</strong> 加锁与解锁</li>
</ul>
</li>
<li><strong>QSemaphore</strong> 提供了一个整型信号量, 是互斥量的泛化</li>
<li><strong>QWaitCondition</strong> 提供了一种方法, 使得线程可以在被另外线程唤醒之前一直休眠</li>
</ul>
<p>参考资料:<br>
<a href="http://www.cnblogs.com/NeuqUstcIim/archive/2008/08/02/1258871.html">Qt 多线程</a><br>
<a href="http://www.cnblogs.com/findumars/p/5176046.html">Qt 线程同步</a></p>
<p>具体的例子参考上面的资料和官方文档, 这里仅解释下重点感念.</p>
<h3 id="qmutex-qreadwriterlock">QMutex 与 QReadWriterLock</h3>
<p>如果使用 <strong>QMutex</strong>, 那么当一个线程对受保护的数据进行读的时候, 那么其它任何线程都不能对受保护的数据进行操作&hellip;</p>
<p>而使用 <strong>QReadWriterLock</strong>, 加了 <strong>QWriteLocker</strong> 的锁和 QMutex 效果一样, 不允许其它任何线程都不能对受保护的数据进行操作,因为我正在写数据内, 还没写完, 你读什么..<br>
但是加了 <strong>QReadLocker</strong> 的锁就不一样了, 它允许其它也使用 <strong>QReadLocker</strong> 的线程对受保护的数据进行读取, 因为大家都是读嘛, 无所谓了, 却不允许使用 <strong>QWriteLocker</strong> 的线程对受保护的数据进行写入, 因为必须要我读完你才能写&hellip;</p>
<h3 id="qsemaphore">QSemaphore</h3>
<p>QSemaphore (信号量)支持两个基本是函数, acquire() 和 release()</p>
<ul>
<li>acquire(n): 尝试获取 n 个资源, 如果没有足够的可用资源, 这个调用将阻塞, 直到足够的资源可用</li>
<li>release(n): 释放 n 个资源, 如果释放的数量大于上面获取的数量, 则可用资源增加, 即这是一个增量的过程</li>
</ul>
<p><strong>那这货的使用场景是什么呢?</strong></p>
<p>举个例子来说明这个问题可能比较好理解一点.</p>
<p>假设有一个餐厅, 信号量的初始值为餐厅凳子总数目, 当有客人到，他就需要凳子, 当凳子被坐下, 可用的凳子数就减少, 当客人离开, 可用的凳子数就增加, 就允许更多的人进入, 如果有 10 个人需要凳子, 但是只有 9 张凳子, 那么这 10 个人将等待, 如果有 4 个人需要凳子, 他们可以直接坐下 (这样就只剩下 5 张凳子空着，那 10 个人将等得更久), 这就类似 <strong>QSemaphore</strong> 的概念.</p>
<p>信号量的一个典型的应用就是用来控制缓冲区的读写,下面通过一个典型用例: 生产者和消费者, 来实现这二者之间的同步.</p>
<p>这里就不用 Python 代码了, 上一份别人的 C++ 代码: <a href="http://www.cnblogs.com/venow/archive/2012/10/15/2724943.html">Qt 信号量 QSemaphore</a></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800">#include &lt;QtCore/QCoreApplication&gt;</span>
<span style="color: #008800">#include &lt;QSemaphore&gt;</span>
<span style="color: #008800">#include &lt;QThread&gt;</span>
<span style="color: #008800">#include &lt;iostream&gt;</span>
<span style="color: #008800">#include &lt;QTime&gt;</span>

<span style="color: #AA22FF; font-weight: bold">const</span> <span style="color: #00BB00; font-weight: bold">int</span> DataSize <span style="color: #666666">=</span> <span style="color: #666666">100</span>;
<span style="color: #AA22FF; font-weight: bold">const</span> <span style="color: #00BB00; font-weight: bold">int</span> BufferSize <span style="color: #666666">=</span> <span style="color: #666666">1</span>;
<span style="color: #00BB00; font-weight: bold">char</span> buffer[BufferSize];

QSemaphore <span style="color: #00A000">freeSpace</span>(BufferSize);
QSemaphore <span style="color: #00A000">usedSpace</span>(<span style="color: #666666">0</span>);  <span style="color: #008800; font-style: italic">// 必须要用 0, 因为要和 freeSpace 共用信号, 也就是说当 freeSpace - 1 时则 usedSpace + 1, 具体看下面的详细分析</span>

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Producer</span> <span style="color: #666666">:</span> <span style="color: #AA22FF; font-weight: bold">public</span> QThread {
<span style="color: #AA22FF; font-weight: bold">protected</span><span style="color: #666666">:</span>
    <span style="color: #00BB00; font-weight: bold">void</span> run() {
        qsrand(QTime(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>).secsTo(QTime<span style="color: #666666">::</span>currentTime()));
        qsrand(<span style="color: #AA22FF">NULL</span>);
        <span style="color: #AA22FF; font-weight: bold">for</span> (<span style="color: #00BB00; font-weight: bold">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> DataSize; <span style="color: #666666">++</span>i) {
            freeSpace.acquire();
            std<span style="color: #666666">::</span>cerr<span style="color: #666666">&lt;&lt;</span><span style="color: #BB4444">&quot;P&quot;</span>;
            usedSpace.release();
        }
    }
};

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Consumer</span> <span style="color: #666666">:</span> <span style="color: #AA22FF; font-weight: bold">public</span> QThread {
<span style="color: #AA22FF; font-weight: bold">protected</span><span style="color: #666666">:</span>
    <span style="color: #00BB00; font-weight: bold">void</span> run() {
        <span style="color: #AA22FF; font-weight: bold">for</span> (<span style="color: #00BB00; font-weight: bold">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> DataSize; <span style="color: #666666">++</span>i) {
            usedSpace.acquire();
            std<span style="color: #666666">::</span>cerr<span style="color: #666666">&lt;&lt;</span><span style="color: #BB4444">&quot;C&quot;</span>;
            freeSpace.release();
        }
        std<span style="color: #666666">::</span>cerr<span style="color: #666666">&lt;&lt;</span>std<span style="color: #666666">::</span>endl;
    }
};

<span style="color: #00BB00; font-weight: bold">int</span> <span style="color: #00A000">main</span>(<span style="color: #00BB00; font-weight: bold">int</span> argc, <span style="color: #00BB00; font-weight: bold">char</span> <span style="color: #666666">*</span>argv[]) {
    Producer producer;
    Consumer consumer;
    producer.start();
    consumer.start();
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>


<p><br>
我们来分析一下, 先来看的 producer 的 run() 方法, 好, 假设已经进入 for 循环:</p>
<ul>
<li>step1: <code>freeSpace.acquire()</code> 从 freeSpace 获取一个可用信号, 因为用 1 来初始化的 freeSpace, 所以这里能正常获取一个信号</li>
<li>step2: 输出 P</li>
<li>step3: <code>usedSpace.release()</code> 释放 usedSpace 的信号</li>
<li>step4: 回到 for 循环首, <code>freeSpace.acquire()</code> 由于第一步已经获取了一个信号, 所以现在阻塞住了</li>
</ul>
<p>但同时, consumer 也会被启动, 并进入 for 循环:</p>
<ul>
<li>step1: <code>usedSpace.acquire()</code> 从 usedSpace 获取一个可用信号, 由于我们开始是用 0 来初始化的 usedSpace, 所以必须等到上面 producer 执行一次第三步, 就也是为什么 usedSpace 要用 0 来初始化的原因</li>
<li>step2: 输出 C</li>
<li>step3: <code>freeSpace.release()</code> 释放 freeSpace 的信号, 于是上面 producer 中的第四步从阻塞中获救了&hellip;</li>
<li>step4: 回到 for 循环首, <code>usedSpace.acquire()</code> 由于第一步已经获取了一个信号, 所以现在阻塞住了, 它必须要等到上面 producer 再走到第三步释放 usedSpace</li>
</ul>
<p>我们重新按照 producer、consumer 各自执行一次的顺序理下这个过程:</p>
<ul>
<li>step1 (producer): <code>freeSpace.acquire()</code> 从 freeSpace 获取一个可用信号, 因为用 1 来初始化的 freeSpace, 所以这里能正常获取一个信号</li>
<li>step1 (consumer): <code>usedSpace.acquire()</code> 从 usedSpace 获取一个可用信号, 由于我们开始是用 0 来初始化的 usedSpace, 所以这里阻塞住
<br><br></li>
<li>step2 (producer): 输出 P</li>
<li>step2 (consumer): 阻塞中
<br><br></li>
<li>step3 (producer): <code>usedSpace.release()</code> 释放 usedSpace 的信号</li>
<li>step3 (consumer): 由于上一步释放了一个 usedSpace 信号, 所以 consumer 从 step2 的阻塞中出来了, 获取一个信号
<br><br></li>
<li>step4 (producer): 回到 for 循环首, <code>freeSpace.acquire()</code> 由于 step1 已经获取了一个信号, 所以现在阻塞住了</li>
<li>step4 (consumer): 输出 C
<br><br></li>
<li>step5 (producer): 阻塞中</li>
<li>step5 (consumer): <code>freeSpace.release()</code> 释放 freeSpace 的信号
<br><br></li>
<li>step6 (producer): 由于上一步释放了一个 freeSpace 信号, 所以 producer 从 step4 的阻塞中出来了, 获取一个信号</li>
<li>step6 (consumer): 回到 for 循环首, <code>usedSpace.acquire()</code> 由于 step3 已经获取了一个信号, 所以现在阻塞住了
<br><br>
重复这个过程 . . .</li>
</ul>
<p><img alt="" src="http://i65.tinypic.com/2yn1cad.jpg" /></p>
<p class="subheader">Category: <a href="http://z351522453.github.com/category/pyqt-kai-fa.html">PyQt 开发</a>

</p>




</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/archives.html">Archives</a>
            <li><a href="http://z351522453.github.com/tags.html">Tags</a>
        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/category/ban-ben-kong-zhi.html">版本控制</a></li>
            <li><a href="http://z351522453.github.com/category/c11xin-te-xing.html">C++11新特性</a></li>
            <li><a href="http://z351522453.github.com/category/cocos2dyou-xi-kai-fa.html">Cocos2d游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://z351522453.github.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://z351522453.github.com/category/dai-ma-da-quan.html">代碼大全</a></li>
            <li><a href="http://z351522453.github.com/category/golang.html">Golang</a></li>
            <li><a href="http://z351522453.github.com/category/hadoop.html">hadoop</a></li>
            <li><a href="http://z351522453.github.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://z351522453.github.com/category/jia-che-bao-dian.html">驾车宝典</a></li>
            <li><a href="http://z351522453.github.com/category/jia-gou-shi-zhi-lu.html">架构师之路</a></li>
            <li><a href="http://z351522453.github.com/category/ling-ji-chu-qt-ru-men.html">零基础 QT 入门</a></li>
            <li><a href="http://z351522453.github.com/category/linux.html">Linux</a></li>
            <li><a href="http://z351522453.github.com/category/luayou-xi-kai-fa.html">Lua游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/pyqt-kai-fa.html">PyQt 开发</a></li>
            <li><a href="http://z351522453.github.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-flask.html">深入浅出 Flask</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-mongodb.html">深入浅出 Mongodb</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-redis.html">深入浅出 Redis</a></li>
            <li><a href="http://z351522453.github.com/category/za-xiang.html">杂项</a></li>
            <li><a href="http://z351522453.github.com/category/zai-xue-java.html">再学 JAVA</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>