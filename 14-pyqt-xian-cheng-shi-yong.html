<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>14、PyQt 线程使用</title>

    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://blog.smallcpp.com/theme/css/pygments.css" />
    <link rel="shortcut icon" type="image/x-icon" href="http://blog.smallcpp.com/theme/images/favicon.ico" />
    <script src="http://blog.smallcpp.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://blog.smallcpp.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://blog.smallcpp.com/14-pyqt-xian-cheng-shi-yong.html" rel="bookmark"
        title="Permalink to 14、PyQt 线程使用">14、PyQt 线程使用</a></h3>
    </header>

<h6 class="subheader" title="2016-05-16T20:40:00+08:00">Mon 16 May 2016
</h6>


    <p>由于 Python 的线程历史性原因, 所以在 PyQt 中还是推荐使用 Qt 的线程机制.</p>
<div class="toc">
<ul>
<li><a href="#qthread">初识 QThread</a></li>
<li><a href="#_1">线程间通信</a></li>
<li><a href="#qt">Qt 的线程同步</a><ul>
<li><a href="#_2">可用的类</a></li>
<li><a href="#qmutex-qreadwriterlock">QMutex 与 QReadWriterLock</a></li>
<li><a href="#qsemaphore">QSemaphore</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="qthread"><a name="user-content-qthread" href="#qthread" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>初识 QThread</h1>
<p>Qt 使用 <code>QThread</code> 来管理线程, 首先我们要从 QThread 继承一个子类, 并重写它的 <code>run()</code> 方法, 我们可以认为, run() 方法就是线程需要执行的代码, 然后在需要的时候, 调用 QThread::start() 方法启动一个线程.
最后, 还需要将 <code>QThread.deleteLater()</code> 方法与 <code>QThread.finished()</code> 信号连接起来, 以便当线程完成时, 系统可以帮我们清除线程实例.</p>
<p>例如:</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #A71D5D">import</span> <span style="color: #555555">time</span>

<span style="color: #A71D5D">class</span> <span style="color: #445588">WorkThread</span>(<span style="color: #333333">QThread</span>):
    <span style="color: #A71D5D">def</span> <span style="color: #795DA3">__int__</span>(<span style="color: #ed6a43">self</span>):
        <span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">finished</span><span style="color: #A71D7E">.</span><span style="color: #333333">connect</span>(<span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">deleteLater</span>)
        <span style="color: #ED6A43">super</span>(<span style="color: #333333">WorkThread</span>, <span style="color: #ed6a43">self</span>)<span style="color: #A71D7E">.</span><span style="color: #333333">__init__</span>()

    <span style="color: #A71D5D">def</span> <span style="color: #795DA3">run</span>(<span style="color: #ed6a43">self</span>):
        <span style="color: #333333">time</span><span style="color: #A71D7E">.</span><span style="color: #333333">sleep</span>(<span style="color: #0086b3">10</span>)

<span style="color: #333333">workThread</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">WorkThread</span>()
<span style="color: #333333">workThread</span><span style="color: #A71D7E">.</span><span style="color: #333333">start</span>()
</pre></div>

<br>
需要注意, 如果你在一个类的方法里 start 一个线程, 你需要将线程实例申明为类的属性, 否则, 当你调用完这个 start 线程的类方法后, 由于方法退出, 局部的线程实例被销毁, 就会报错: <code>QThread: Destroyed while thread is still running</code>.</p>
<p>例如下面这样就会报错:</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #A71D5D">def</span> <span style="color: #795DA3">word_start</span>(<span style="color: #ed6a43">self</span>):
    <span style="color: #333333">workThread</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">WorkThread</span>()
    <span style="color: #333333">workThread</span><span style="color: #A71D7E">.</span><span style="color: #333333">start</span>()
</pre></div>

<br>
要改成:</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #A71D5D">def</span> <span style="color: #795DA3">word_start</span>(<span style="color: #ed6a43">self</span>):
    <span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">workThread</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">WorkThread</span>()
    <span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">workThread</span><span style="color: #A71D7E">.</span><span style="color: #333333">start</span>()
</pre></div>

<br></p>
<h1 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>线程间通信</h1>
<p>在 Qt 中, 可以很方便的利用信号槽的机制在多线程间进行通信:</p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #A71D5D">import</span> <span style="color: #555555">time</span>
<span style="color: #A71D5D">from</span> <span style="color: #555555">PyQt4.QtCore</span> <span style="color: #A71D5D">import</span> <span style="color: #333333">pyqtSignal</span>

<span style="color: #A71D5D">class</span> <span style="color: #445588">WorkThread</span>(<span style="color: #333333">QThread</span>):
    <span style="color: #333333">sin_out</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">pyqtSignal</span>()  <span style="color: #999988; font-style: italic"># 定义一个信号</span>

    <span style="color: #A71D5D">def</span> <span style="color: #795DA3">__int__</span>(<span style="color: #ed6a43">self</span>):
        <span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">finished</span><span style="color: #A71D7E">.</span><span style="color: #333333">connect</span>(<span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">deleteLater</span>)
        <span style="color: #ED6A43">super</span>(<span style="color: #333333">WorkThread</span>, <span style="color: #ed6a43">self</span>)<span style="color: #A71D7E">.</span><span style="color: #333333">__init__</span>()

    <span style="color: #A71D5D">def</span> <span style="color: #795DA3">run</span>(<span style="color: #ed6a43">self</span>):
        <span style="color: #333333">time</span><span style="color: #A71D7E">.</span><span style="color: #333333">sleep</span>(<span style="color: #0086b3">10</span>)
        <span style="color: #ed6a43">self</span><span style="color: #A71D7E">.</span><span style="color: #333333">sin_out</span><span style="color: #A71D7E">.</span><span style="color: #333333">emit</span>()  <span style="color: #999988; font-style: italic"># 发射信号</span>

<span style="color: #A71D5D">def</span> <span style="color: #795DA3">on_output</span>():
    <span style="color: #A71D5D">print</span> <span style="color: #183691">u&#39;线程结束&#39;</span>

<span style="color: #333333">workThread</span> <span style="color: #A71D7E">=</span> <span style="color: #333333">WorkThread</span>()
<span style="color: #333333">workThread</span><span style="color: #A71D7E">.</span><span style="color: #333333">sin_out</span><span style="color: #A71D7E">.</span><span style="color: #333333">connect</span>(<span style="color: #333333">on_output</span>)  <span style="color: #999988; font-style: italic"># 连接信号槽</span>
<span style="color: #333333">workThread</span><span style="color: #A71D7E">.</span><span style="color: #333333">start</span>()
</pre></div>

<br></p>
<h1 id="qt"><a name="user-content-qt" href="#qt" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Qt 的线程同步</h1>
<h3 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>可用的类</h3>
<p>Qt 提供以下几个类来保证线程同步问题:</p>
<ul>
<li><strong>QMutex</strong> 提供相互排斥的锁, 或互斥量<ul>
<li><strong>QMutexLocker</strong> 是一个便利类, 它可以自动对 QMutex 加锁与解锁</li>
</ul>
</li>
<li><strong>QReadWriterLock</strong> 提供了一个可以同时读/写操作的锁<ul>
<li><strong>QWriteLocker</strong> 与 <strong>QReadLocker</strong> 是便利类, 它们自动对 <strong>QReadWriteLock</strong> 加锁与解锁</li>
</ul>
</li>
<li><strong>QSemaphore</strong> 提供了一个整型信号量, 是互斥量的泛化</li>
<li><strong>QWaitCondition</strong> 提供了一种方法, 使得线程可以在被另外线程唤醒之前一直休眠</li>
</ul>
<p>参考资料:<br>
<a href="http://www.cnblogs.com/NeuqUstcIim/archive/2008/08/02/1258871.html">Qt 多线程</a><br>
<a href="http://www.cnblogs.com/findumars/p/5176046.html">Qt 线程同步</a></p>
<p>具体的例子参考上面的资料和官方文档, 这里仅解释下重点感念.</p>
<h3 id="qmutex-qreadwriterlock"><a name="user-content-qmutex-qreadwriterlock" href="#qmutex-qreadwriterlock" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>QMutex 与 QReadWriterLock</h3>
<p>如果使用 <strong>QMutex</strong>, 那么当一个线程对受保护的数据进行读的时候, 那么其它任何线程都不能对受保护的数据进行操作&hellip;</p>
<p>而使用 <strong>QReadWriterLock</strong>, 加了 <strong>QWriteLocker</strong> 的锁和 QMutex 效果一样, 不允许其它任何线程都不能对受保护的数据进行操作,因为我正在写数据内, 还没写完, 你读什么..<br>
但是加了 <strong>QReadLocker</strong> 的锁就不一样了, 它允许其它也使用 <strong>QReadLocker</strong> 的线程对受保护的数据进行读取, 因为大家都是读嘛, 无所谓了, 却不允许使用 <strong>QWriteLocker</strong> 的线程对受保护的数据进行写入, 因为必须要我读完你才能写&hellip;</p>
<h3 id="qsemaphore"><a name="user-content-qsemaphore" href="#qsemaphore" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>QSemaphore</h3>
<p>QSemaphore (信号量)支持两个基本是函数, acquire() 和 release()</p>
<ul>
<li>acquire(n): 尝试获取 n 个资源, 如果没有足够的可用资源, 这个调用将阻塞, 直到足够的资源可用</li>
<li>release(n): 释放 n 个资源, 如果释放的数量大于上面获取的数量, 则可用资源增加, 即这是一个增量的过程</li>
</ul>
<p><strong>那这货的使用场景是什么呢?</strong></p>
<p>举个例子来说明这个问题可能比较好理解一点.</p>
<p>假设有一个餐厅, 信号量的初始值为餐厅凳子总数目, 当有客人到，他就需要凳子, 当凳子被坐下, 可用的凳子数就减少, 当客人离开, 可用的凳子数就增加, 就允许更多的人进入, 如果有 10 个人需要凳子, 但是只有 9 张凳子, 那么这 10 个人将等待, 如果有 4 个人需要凳子, 他们可以直接坐下 (这样就只剩下 5 张凳子空着，那 10 个人将等得更久), 这就类似 <strong>QSemaphore</strong> 的概念.</p>
<p>信号量的一个典型的应用就是用来控制缓冲区的读写,下面通过一个典型用例: 生产者和消费者, 来实现这二者之间的同步.</p>
<p>这里就不用 Python 代码了, 上一份别人的 C++ 代码: <a href="http://www.cnblogs.com/venow/archive/2012/10/15/2724943.html">Qt 信号量 QSemaphore</a></p>
<p><div class="codehilite" style="background: #F7F7F7"><pre style="line-height: 125%"><span></span><span style="color: #999999; font-weight: bold">#include</span> <span style="color: #999988; font-style: italic">&lt;QtCore/QCoreApplication&gt;</span><span style="color: #999999; font-weight: bold"></span>
<span style="color: #999999; font-weight: bold">#include</span> <span style="color: #999988; font-style: italic">&lt;QSemaphore&gt;</span><span style="color: #999999; font-weight: bold"></span>
<span style="color: #999999; font-weight: bold">#include</span> <span style="color: #999988; font-style: italic">&lt;QThread&gt;</span><span style="color: #999999; font-weight: bold"></span>
<span style="color: #999999; font-weight: bold">#include</span> <span style="color: #999988; font-style: italic">&lt;iostream&gt;</span><span style="color: #999999; font-weight: bold"></span>
<span style="color: #999999; font-weight: bold">#include</span> <span style="color: #999988; font-style: italic">&lt;QTime&gt;</span><span style="color: #999999; font-weight: bold"></span>

<span style="color: #A71D5D">const</span> <span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #333333">DataSize</span> <span style="color: #A71D7E">=</span> <span style="color: #0086b3">100</span>;
<span style="color: #A71D5D">const</span> <span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #333333">BufferSize</span> <span style="color: #A71D7E">=</span> <span style="color: #0086b3">1</span>;
<span style="color: #A71D5D; font-weight: bold">char</span> <span style="color: #333333">buffer</span>[<span style="color: #333333">BufferSize</span>];

<span style="color: #333333">QSemaphore</span> <span style="color: #795DA3">freeSpace</span>(<span style="color: #333333">BufferSize</span>);
<span style="color: #333333">QSemaphore</span> <span style="color: #795DA3">usedSpace</span>(<span style="color: #0086b3">0</span>);  <span style="color: #999988; font-style: italic">// 必须要用 0, 因为要和 freeSpace 共用信号, 也就是说当 freeSpace - 1 时则 usedSpace + 1, 具体看下面的详细分析</span>

<span style="color: #A71D5D">class</span> <span style="color: #445588">Producer</span> <span style="color: #A71D7E">:</span> <span style="color: #A71D5D">public</span> <span style="color: #333333">QThread</span> {
<span style="color: #A71D5D">protected</span><span style="color: #A71D7E">:</span>
    <span style="color: #A71D5D; font-weight: bold">void</span> <span style="color: #333333">run</span>() {
        <span style="color: #333333">qsrand</span>(<span style="color: #333333">QTime</span>(<span style="color: #0086b3">0</span>, <span style="color: #0086b3">0</span>, <span style="color: #0086b3">0</span>).<span style="color: #333333">secsTo</span>(<span style="color: #333333">QTime</span><span style="color: #A71D7E">::</span><span style="color: #333333">currentTime</span>()));
        <span style="color: #333333">qsrand</span>(<span style="color: #ED6A43">NULL</span>);
        <span style="color: #A71D5D">for</span> (<span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #333333">i</span> <span style="color: #A71D7E">=</span> <span style="color: #0086b3">0</span>; <span style="color: #333333">i</span> <span style="color: #A71D7E">&lt;</span> <span style="color: #333333">DataSize</span>; <span style="color: #A71D7E">++</span><span style="color: #333333">i</span>) {
            <span style="color: #333333">freeSpace</span>.<span style="color: #333333">acquire</span>();
            <span style="color: #333333">std</span><span style="color: #A71D7E">::</span><span style="color: #333333">cerr</span><span style="color: #A71D7E">&lt;&lt;</span><span style="color: #183691">&quot;P&quot;</span>;
            <span style="color: #333333">usedSpace</span>.<span style="color: #333333">release</span>();
        }
    }
};

<span style="color: #A71D5D">class</span> <span style="color: #445588">Consumer</span> <span style="color: #A71D7E">:</span> <span style="color: #A71D5D">public</span> <span style="color: #333333">QThread</span> {
<span style="color: #A71D5D">protected</span><span style="color: #A71D7E">:</span>
    <span style="color: #A71D5D; font-weight: bold">void</span> <span style="color: #333333">run</span>() {
        <span style="color: #A71D5D">for</span> (<span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #333333">i</span> <span style="color: #A71D7E">=</span> <span style="color: #0086b3">0</span>; <span style="color: #333333">i</span> <span style="color: #A71D7E">&lt;</span> <span style="color: #333333">DataSize</span>; <span style="color: #A71D7E">++</span><span style="color: #333333">i</span>) {
            <span style="color: #333333">usedSpace</span>.<span style="color: #333333">acquire</span>();
            <span style="color: #333333">std</span><span style="color: #A71D7E">::</span><span style="color: #333333">cerr</span><span style="color: #A71D7E">&lt;&lt;</span><span style="color: #183691">&quot;C&quot;</span>;
            <span style="color: #333333">freeSpace</span>.<span style="color: #333333">release</span>();
        }
        <span style="color: #333333">std</span><span style="color: #A71D7E">::</span><span style="color: #333333">cerr</span><span style="color: #A71D7E">&lt;&lt;</span><span style="color: #333333">std</span><span style="color: #A71D7E">::</span><span style="color: #333333">endl</span>;
    }
};

<span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #795DA3">main</span>(<span style="color: #A71D5D; font-weight: bold">int</span> <span style="color: #333333">argc</span>, <span style="color: #A71D5D; font-weight: bold">char</span> <span style="color: #A71D7E">*</span><span style="color: #333333">argv</span>[]) {
    <span style="color: #333333">Producer</span> <span style="color: #333333">producer</span>;
    <span style="color: #333333">Consumer</span> <span style="color: #333333">consumer</span>;
    <span style="color: #333333">producer</span>.<span style="color: #333333">start</span>();
    <span style="color: #333333">consumer</span>.<span style="color: #333333">start</span>();
    <span style="color: #A71D5D">return</span> <span style="color: #0086b3">0</span>;
}
</pre></div>

<br>
我们来分析一下, 先来看的 producer 的 run() 方法, 好, 假设已经进入 for 循环:</p>
<ul>
<li>step1: <code>freeSpace.acquire()</code> 从 freeSpace 获取一个可用信号, 因为用 1 来初始化的 freeSpace, 所以这里能正常获取一个信号</li>
<li>step2: 输出 P</li>
<li>step3: <code>usedSpace.release()</code> 释放 usedSpace 的信号</li>
<li>step4: 回到 for 循环首, <code>freeSpace.acquire()</code> 由于第一步已经获取了一个信号, 所以现在阻塞住了</li>
</ul>
<p>但同时, consumer 也会被启动, 并进入 for 循环:</p>
<ul>
<li>step1: <code>usedSpace.acquire()</code> 从 usedSpace 获取一个可用信号, 由于我们开始是用 0 来初始化的 usedSpace, 所以必须等到上面 producer 执行一次第三步, 就也是为什么 usedSpace 要用 0 来初始化的原因</li>
<li>step2: 输出 C</li>
<li>step3: <code>freeSpace.release()</code> 释放 freeSpace 的信号, 于是上面 producer 中的第四步从阻塞中获救了&hellip;</li>
<li>step4: 回到 for 循环首, <code>usedSpace.acquire()</code> 由于第一步已经获取了一个信号, 所以现在阻塞住了, 它必须要等到上面 producer 再走到第三步释放 usedSpace</li>
</ul>
<p>我们重新按照 producer、consumer 各自执行一次的顺序理下这个过程:</p>
<ul>
<li>step1 (producer): <code>freeSpace.acquire()</code> 从 freeSpace 获取一个可用信号, 因为用 1 来初始化的 freeSpace, 所以这里能正常获取一个信号</li>
<li>step1 (consumer): <code>usedSpace.acquire()</code> 从 usedSpace 获取一个可用信号, 由于我们开始是用 0 来初始化的 usedSpace, 所以这里阻塞住
<br><br></li>
<li>step2 (producer): 输出 P</li>
<li>step2 (consumer): 阻塞中
<br><br></li>
<li>step3 (producer): <code>usedSpace.release()</code> 释放 usedSpace 的信号</li>
<li>step3 (consumer): 由于上一步释放了一个 usedSpace 信号, 所以 consumer 从 step2 的阻塞中出来了, 获取一个信号
<br><br></li>
<li>step4 (producer): 回到 for 循环首, <code>freeSpace.acquire()</code> 由于 step1 已经获取了一个信号, 所以现在阻塞住了</li>
<li>step4 (consumer): 输出 C
<br><br></li>
<li>step5 (producer): 阻塞中</li>
<li>step5 (consumer): <code>freeSpace.release()</code> 释放 freeSpace 的信号
<br><br></li>
<li>step6 (producer): 由于上一步释放了一个 freeSpace 信号, 所以 producer 从 step4 的阻塞中出来了, 获取一个信号</li>
<li>step6 (consumer): 回到 for 循环首, <code>usedSpace.acquire()</code> 由于 step3 已经获取了一个信号, 所以现在阻塞住了
<br><br>
重复这个过程 . . .</li>
</ul>
<p><img alt="" src="http://i65.tinypic.com/2yn1cad.jpg" /></p>
<p class="subheader">Category: <a href="http://blog.smallcpp.com/category/pyqt-kai-fa.html">PyQt 开发</a>

</p>




</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/archives.html">Archives</a>
            <li><a href="http://blog.smallcpp.com/tags.html">Tags</a>
        </ul>

        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://blog.smallcpp.com/category/ban-ben-kong-zhi.html">版本控制</a></li>
            <li><a href="http://blog.smallcpp.com/category/c11-xin-te-xing.html">C++11 新特性</a></li>
            <li><a href="http://blog.smallcpp.com/category/cocos2d-you-xi-kai-fa.html">Cocos2d 游戏开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://blog.smallcpp.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://blog.smallcpp.com/category/du-shu-bi-ji.html">读书笔记</a></li>
            <li><a href="http://blog.smallcpp.com/category/golang.html">Golang</a></li>
            <li><a href="http://blog.smallcpp.com/category/hadoop.html">hadoop</a></li>
            <li><a href="http://blog.smallcpp.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://blog.smallcpp.com/category/ling-ji-chu-qt-ru-men.html">零基础 QT 入门</a></li>
            <li><a href="http://blog.smallcpp.com/category/linux.html">Linux</a></li>
            <li><a href="http://blog.smallcpp.com/category/lua-you-xi-kai-fa.html">Lua 游戏开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/pyqt-kai-fa.html">PyQt 开发</a></li>
            <li><a href="http://blog.smallcpp.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a></li>
            <li><a href="http://blog.smallcpp.com/category/shen-ru-qian-chu-mongodb.html">深入浅出 Mongodb</a></li>
            <li><a href="http://blog.smallcpp.com/category/shen-ru-qian-chu-redis.html">深入浅出 Redis</a></li>
            <li><a href="http://blog.smallcpp.com/category/za-xiang.html">杂项</a></li>
            <li><a href="http://blog.smallcpp.com/category/zai-xue-java.html">再学 JAVA</a></li>
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>