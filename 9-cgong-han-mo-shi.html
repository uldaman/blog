<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>9、[C++]工厂模式</title>

    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/style.css" />
    <link rel="stylesheet" href="http://z351522453.github.com/theme/css/pygments.css" />	
    <script src="http://z351522453.github.com/theme/js/modernizr.js"></script>
</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="http://z351522453.github.com">Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用.</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="http://z351522453.github.com/9-cgong-han-mo-shi.html" rel="bookmark"
        title="Permalink to 9、[C++]工厂模式">9、[C++]工厂模式</a></h3>
    </header>

<h6 class="subheader" title="2015-02-15T14:24:00+08:00">周日 15 二月 2015
</h6>


    <p>回想一下, 我们之前的简单工厂模式, <a href="http://www.cnblogs.com/hanxiao-martin/p/4289502.html">http://www.cnblogs.com/hanxiao-martin/p/4289502.html</a></p>
<p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断, 根据客户端的选择条件动态实例化相关的类, 对于客户端来说, 去除了与具体产品的依赖, 在我们的计算器程序中, 只需要把&rsquo;+&rsquo;等符号给工厂就可以生成相应的实例, 然后客户端直接做运算就好了.</p>
<p>但是同样的, 他还有个缺点, 就是这个工厂类本身并不容易扩展和维护, 例如现在要添加一个开方的计算, 首先从Operation继承一个开方类, 这一步没有问题, 接下来就要去给运算工厂类的方法里加&rsquo;case&rsquo;的分支条件, 这修改了原有的类, 违背了我们的<strong>&ldquo;开放-封闭原则&rdquo;,</strong> 于是, 工厂模式就来了&hellip;</p>
<p>工厂模式: 定义一个用于创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延迟到其子类.</p>
<p><a href="http://images.cnitblog.com/blog/723444/201502/132041357457281.jpg"><img alt="工厂模式" src="http://images.cnitblog.com/blog/723444/201502/132041374791953.jpg" /></a></p>
<p>[cpp]#include <iostream>
using namespace std;</p>
<p>class Operation {
public:
    virtual double GetResult() = 0;</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">double m_dNum_A = 0;
double m_dNum_B = 0;
</pre></div>


<p>};</p>
<p>class OperationAdd : public Operation {
public:
    virtual double GetResult() {
        double dResult = m_dNum_A + m_dNum_B;
        return dResult;
    }
};</p>
<p>class OperationSub : public Operation {
public:
    virtual double GetResult() {
        double dResult = m_dNum_A - m_dNum_B;
        return dResult;
    }
};</p>
<p>class OperationMul : public Operation {
public:
    virtual double GetResult() {
        double dResult = m_dNum_A * m_dNum_B;
        return dResult;
    }
};</p>
<p>class OperationDiv : public Operation {
public:
    virtual double GetResult() {
        double dResult = m_dNum_A / m_dNum_B;
        return dResult;
    }
};</p>
<p>class IFactory {
public:
    virtual Operation* CreateOperate() = 0;
};</p>
<p>class AddFactory
    : public IFactory {
public:
    Operation* CreateOperate() {
        return new OperationAdd();
    }
};</p>
<p>class SubFactory
    : public IFactory {
public:
    Operation* CreateOperate() {
        return new OperationSub();
    }
};</p>
<p>class MulFactory
    : public IFactory {
public:
    Operation* CreateOperate() {
        return new OperationMul();
    }
};</p>
<p>class DivFactory
    : public IFactory {
public:
    Operation* CreateOperate() {
        return new OperationDiv();
    }
};</p>
<p>int _tmain(int argc, _TCHAR<em> argv[]) {
    IFactory</em> operFactory = NULL;
    char cOp;
    cout &lt;&lt; &ldquo;请输入操作符(+ - * / . . .):&rdquo; &lt;&lt; endl;
    cin &gt;&gt; cOp;</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">switch (cOp) {
case &#39;+&#39;:
    operFactory = new AddFactory();
    break;
case &#39;-&#39;:
    operFactory = new SubFactory();
    break;
case &#39;*&#39;:
    operFactory = new MulFactory();
    break;
case &#39;/&#39;:
    operFactory = new DivFactory();
    break;
}

if (operFactory != NULL) {
    Operation* pOper = operFactory-&gt;CreateOperate();
    cout &lt;&lt; &quot;请输入第一个数:&quot; &lt;&lt; endl;
    cin &gt;&gt; pOper-&gt;m_dNum_A;
    cout &lt;&lt; &quot;请输入第二个数:&quot; &lt;&lt; endl;
    cin &gt;&gt; pOper-&gt;m_dNum_B;

    try {
        double dResult = pOper-&gt;GetResult();
        cout &lt;&lt; &quot;结果是: &quot; &lt;&lt; dResult &lt;&lt; endl;
    } catch (...) {
        cout &lt;&lt; &quot;请输入正确操作数&quot; &lt;&lt; endl;
    }
}

system(&quot;PAUSE&quot;);
return 0;
</pre></div>


<p>}[/cpp]</p>
<p>这是我用C++模拟出来的工厂模式, 这个例子虽然实现出了工厂模式, 它将选择判断的问题丢给了客户端, 使得客户端维护起来变得麻烦, 如果要添加新运算,  本来是改工厂类, 而现在是改客户端, 看起来好像变得更麻烦了, 那为什么还要用工厂模式呢?</p>
<p><strong>那到底什么时候该用工厂模式呢?</strong></p>
<p>来看&lt;大话设计模式&gt;中雷锋的例子, 现在有个雷锋类, 它有扫地, 洗衣, 买米三个方法, 现在有三个快毕业的大学生要学习雷锋做好事, 于是他们就要继承雷锋那个类, 这里一开始用简单工厂模式, 有个简单的&rdquo;雷锋工厂&rdquo; &ndash; SimpleFactory, 通过传入的参数来实例化对象. 因为学习雷锋出来学生外还是社会志愿者, 所以这个简单工厂类可能像下面这样:</p>
<p><a href="http://images.cnitblog.com/blog/723444/201502/132041389644465.png"><img alt="image" src="http://images.cnitblog.com/blog/723444/201502/132041404641207.png" /></a></p>
<p>再来看客户端代码:</p>
<p><a href="http://images.cnitblog.com/blog/723444/201502/132041416987262.png"><img alt="image" src="http://images.cnitblog.com/blog/723444/201502/132041432613220.png" /></a></p>
<p>好, 现在需求来了,  这三个学生毕业了, 他们从大学生编程了社区志愿者, 我们需要改原码, 把三名创建&rdquo;学雷锋的大学生&rdquo;换成&rdquo;社区志愿者&rdquo;, 我们需要改动三个地方. 那么就里就会出现重复的操作, 如果改成工厂模式来实现:</p>
<p><a href="http://images.cnitblog.com/blog/723444/201502/132041489646743.png"><img alt="image" src="http://images.cnitblog.com/blog/723444/201502/132041508867656.png" /></a></p>
<p>再来看客户端代码:</p>
<p><a href="http://images.cnitblog.com/blog/723444/201502/132041524176155.png"><img alt="image" src="http://images.cnitblog.com/blog/723444/201502/132041532293741.png" /></a></p>
<p>此时, 如果我们换成&rdquo;社区志愿者&rdquo;, 只要修改第一句代码就可以了.</p>
<p>写在最后:</p>
<p>其实什么时候用简单工厂, 什么时候用工厂, 我还没完全弄明白, 下面这段摘自网上的分析:</p>
<blockquote>工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。但是，工厂方法模式就一定比简单工厂模式好呢？笔者的答案是不一定。下面笔者将详细比较两种模式。

>
>

>   1. 结构复杂度 从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。
>

>   2. 代码复杂度 代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。
>

>   3. 客户端编程难度 工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。
>

>   4. 管理上的难度 这是个关键的问题。 我 们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就没有扩展性呢？答案是否定的。简单工厂模式同 样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但笔者认为不需要太拘 泥于设计理论，要知道，sun提供的java官方工具包中也有想到多没有满足OCP的例子啊（java.util.Calendar这个抽象类就不满足 OCP，具体原因大家可以分析下）。然后我们从维护性的角度分析下。首先是工厂模式, 假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时 需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些麻烦，当多个产品类需要修改是，简单工厂模式 仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大不了把这个类重写）。

由以上的分析，笔者认为简单工厂模式更好用更方便些。当然这只是笔者的个人看法而已，毕竟公认的，工厂方法模式比简单工厂模式更“先进”。但有时过于先进的东西未必适合自己，这个见仁见智吧。
>

</blockquote>

<p>??</p>
<p class="subheader">Category: <a href="http://z351522453.github.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a>

</p>




</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/archives.html">Archives</a>
            <li><a href="http://z351522453.github.com/tags.html">Tags</a>
        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="http://z351522453.github.com/category/ban-ben-kong-zhi.html">版本控制</a></li>
            <li><a href="http://z351522453.github.com/category/c11xin-te-xing.html">C++11新特性</a></li>
            <li><a href="http://z351522453.github.com/category/cocos2dyou-xi-kai-fa.html">Cocos2d游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/da-hua-she-ji-mo-shi.html">大话设计模式</a></li>
            <li><a href="http://z351522453.github.com/category/da-shu-ju.html">大数据</a></li>
            <li><a href="http://z351522453.github.com/category/dai-ma-da-quan.html">代碼大全</a></li>
            <li><a href="http://z351522453.github.com/category/golang.html">Golang</a></li>
            <li><a href="http://z351522453.github.com/category/hadoop.html">hadoop</a></li>
            <li><a href="http://z351522453.github.com/category/hei-ke-ji.html">黑科技</a></li>
            <li><a href="http://z351522453.github.com/category/jia-che-bao-dian.html">驾车宝典</a></li>
            <li><a href="http://z351522453.github.com/category/jia-gou-shi-zhi-lu.html">架构师之路</a></li>
            <li><a href="http://z351522453.github.com/category/ling-ji-chu-qt-ru-men.html">零基础 QT 入门</a></li>
            <li><a href="http://z351522453.github.com/category/linux.html">Linux</a></li>
            <li><a href="http://z351522453.github.com/category/luayou-xi-kai-fa.html">Lua游戏开发</a></li>
            <li><a href="http://z351522453.github.com/category/pyqt-kai-fa.html">PyQt 开发</a></li>
            <li><a href="http://z351522453.github.com/category/python-cong-ru-men-dao-fang-qi.html">Python 从入门到放弃</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-flask.html">深入浅出 Flask</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-mongodb.html">深入浅出 Mongodb</a></li>
            <li><a href="http://z351522453.github.com/category/shen-ru-qian-chu-redis.html">深入浅出 Redis</a></li>
            <li><a href="http://z351522453.github.com/category/za-xiang.html">杂项</a></li>
            <li><a href="http://z351522453.github.com/category/zai-xue-java.html">再学 JAVA</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="http://blog.csdn.net/u010850265">CSDN</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
              <!--                  <p>Small Cpp | 勿在浮沙筑高台, 练从难处练, 用从易处用. by martin</p> -->
            </div>
            </div>
    </div>
</footer>
</body>
</html>