<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>04. LuaGlue 函数 与 Lua 运行时栈</title>
  <meta name="description" content="">
  <meta name="author" content="martin">

  <!-- Style Meta Data -->
  <link rel="stylesheet" href="http://blog.smallcpp.cn/theme/css/notebook.css" type="text/css" />
  <link rel="shortcut icon" href="http://blog.smallcpp.cn/theme/images/avatar.png">

  <!-- Feed Meta Data -->
  <link href="http://blog.smallcpp.cn/" type="application/atom+xml" rel="alternate" title="Small Cpp ATOM Feed" />

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="http://blog.smallcpp.cn/theme/images/avatar.png">

<meta name="twitter:creator" content="">
<meta name="twitter:url" content="http://blog.smallcpp.cn/04-luaglue-han-shu-yu-lua-yun-xing-shi-zhan.html">
<meta name="twitter:title" content="Small Cpp ~ 04. LuaGlue 函数 与 Lua 运行时栈">
<meta name="twitter:description" content="在之前, 我们写了一个很简单的 LuaGlue 函数, 然而这个函数不接收参数和也没有返回值, 但是不可否认的是, LuaGlue 函数具有传递参数和返回值的能力. 这种功能通过 Lua 运行时栈来完实现. 要搞明白 Lua 栈, 首先要搞清楚栈的索引是如何定义的. 当初始化一个栈的时候, 它的栈底索引是 1, 而栈顶相对索引是 -1. Lua 栈的结构和 C/C++ 的栈具有异曲同工之处, 即先进后出, 最选压栈的元素被保存在栈底. 假设存在一个 LuaGlue 函数 …">

<!-- Facebook Meta Data -->
<meta property="og:title" content="Small Cpp ~ 04. LuaGlue 函数 与 Lua 运行时栈" />
<meta property="og:description" content="在之前, 我们写了一个很简单的 LuaGlue 函数, 然而这个函数不接收参数和也没有返回值, 但是不可否认的是, LuaGlue 函数具有传递参数和返回值的能力. 这种功能通过 Lua 运行时栈来完实现. 要搞明白 Lua 栈, 首先要搞清楚栈的索引是如何定义的. 当初始化一个栈的时候, 它的栈底索引是 1, 而栈顶相对索引是 -1. Lua 栈的结构和 C/C++ 的栈具有异曲同工之处, 即先进后出, 最选压栈的元素被保存在栈底. 假设存在一个 LuaGlue 函数 …" />
<meta property="og:image" content="theme/images/avatar.png" />
</head>

<body>
  <!-- Sidebar -->
  <aside>
    <p><a href="http://blog.smallcpp.cn"><img id="avatar" src="http://blog.smallcpp.cn/theme/images/avatar.png"></a></p>
    <h1>Small Cpp</h1>
    <p>勿在浮沙筑高台, 练从难处练, 用从易处用.</p>
    <hr>
    <h2>Social</h2>
    <ul class="social">
      <a href="http://blog.csdn.net/u010850265">CSDN</a></li>
    </ul>
    <h2>Categories</h2>
    <ul class="navbar">
      <li><a href="http://blog.smallcpp.cn/category/c11.html">C++11</a></li>
      <li><a href="http://blog.smallcpp.cn/category/da-shu-ju.html">大数据</a></li>
      <li><a href="http://blog.smallcpp.cn/category/du-shu-bi-ji.html">读书笔记</a></li>
      <li><a href="http://blog.smallcpp.cn/category/golang.html">Golang</a></li>
      <li><a href="http://blog.smallcpp.cn/category/hei-ke-ji.html">黑科技</a></li>
      <li><a href="http://blog.smallcpp.cn/category/java.html">Java</a></li>
      <li><a href="http://blog.smallcpp.cn/category/linux.html">Linux</a></li>
      <li class="active"><a href="http://blog.smallcpp.cn/category/lua.html">Lua</a></li>
      <li><a href="http://blog.smallcpp.cn/category/mongodb.html">Mongodb</a></li>
      <li><a href="http://blog.smallcpp.cn/category/pyqt.html">PyQt</a></li>
      <li><a href="http://blog.smallcpp.cn/category/python.html">Python</a></li>
      <li><a href="http://blog.smallcpp.cn/category/qt.html">QT</a></li>
      <li><a href="http://blog.smallcpp.cn/category/qu-kuai-lian.html">区块链</a></li>
      <li><a href="http://blog.smallcpp.cn/category/redis.html">Redis</a></li>
      <li><a href="http://blog.smallcpp.cn/category/ruan-jian-she-ji.html">软件设计</a></li>
      <li><a href="http://blog.smallcpp.cn/category/za-xiang.html">杂项</a></li>
    </ul> 
  </aside>

  <!-- Content -->
  <article>
<section id="content">
    <article>
        <header class="post_list">
            <h2 class="post_title"><a href="http://blog.smallcpp.cn/04-luaglue-han-shu-yu-lua-yun-xing-shi-zhan.html" rel="bookmark" title="Permalink to 04. LuaGlue 函数 与 Lua 运行时栈">04. LuaGlue 函数 与 Lua 运行时栈</a></h2>
            <span>Par </span>
            <a href="http://blog.smallcpp.cn/author/martin.html">@Martin</a>
            <span> dans </span>
            <span class="post_category"><a href="http://blog.smallcpp.cn/category/lua.html" rel="bookmark" title="Permalink to Lua">[ Lua ]</a></span>
            <span> le </span>
            <span class="post_date">Sun 15 March 2015</span>
            <div></div>
            <div><span>Tags : </span>
            </div>
        </header>
        <div class="entry-content">
            <p>在之前, 我们写了一个很简单的 LuaGlue 函数, 然而这个函数不接收参数和也没有返回值, 但是不可否认的是, LuaGlue 函数具有传递参数和返回值的能力.<br>
这种功能通过 Lua 运行时栈来完实现.</p>
<p>要搞明白 Lua 栈, 首先要搞清楚栈的索引是如何定义的.</p>
<p><img alt="" src="http://i57.tinypic.com/219xv1h.jpg"></p>
<p>当初始化一个栈的时候, 它的栈底索引是 1, 而栈顶相对索引是 -1.<br>
Lua 栈的结构和 C/C++ 的栈具有异曲同工之处, 即先进后出, 最选压栈的元素被保存在栈底.</p>
<p>假设存在一个 LuaGlue 函数 Add(int i, intj), 它接收两个整型参数并返回相加的结果;<br>
现在, 我们在 Lua 脚本中使用它: local nRet = Add(11, 12);<br>
我们来看看 Lua 栈的变化过程.<br>
当执行到这段代码的时候, 首先把函数名(Add)压栈, 然后将第一个参数(11)压栈, 再将第二个参数(12)压栈, 此时栈变成这样:</p>
<p><img alt="" src="http://i60.tinypic.com/2ch9b4h.jpg">.</p>
<p>然后 Lua 解释器取出栈底的函数名, 通过函数名找到函数的入口, 进入函数主体, 此时栈是这样的:</p>
<p><img alt="" src="http://i57.tinypic.com/2el9yy8.jpg"></p>
<p>此时已经进入 C/C++ 写的 LuaGlue 函数底层代码.<br>
C/C++ 从 Lua 栈中取出里面的两个参数进行加法计算, 然后将结果压栈, 现在栈变成了这样:</p>
<p><img alt="" src="http://i61.tinypic.com/5zdtzk.jpg"></p>
<p>函数调用成功返回之后, Lua 解释器释放掉参数栈保留返回值栈, 此时栈是这样的:</p>
<p><img alt="" src="http://i61.tinypic.com/2ev6h3k.jpg"></p>
<p>最后, Lua 解释器将这个返回值取出并赋值给 nRet, 此时 Lua 栈为空.</p>
<p>那么问题来了!<br>
在 C/C++ 写的 LuaGlue 函数底层代码中, 怎么取出这些参数, 然后又怎么将计算结果压回栈, 最后又是怎么设置栈底指针的呢?<br>
cLua 类中的 GetIntArgument 方法能够从 Lua 栈中返回一个整型数据.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #00688B; font-weight: bold">int</span> cLua::GetIntArgument(<span style="color: #00688B; font-weight: bold">int</span> num, <span style="color: #00688B; font-weight: bold">int</span> nDefault <span style="color: #228B22">/*= 0*/</span>) {
    <span style="color: #8B008B; font-weight: bold">return</span> luaL_optinteger(m_pScriptContext, num, nDefault);
}
</pre></div>


<p><br>
而 cLua 类中的 PushInt 方法能够向 Lua 栈中压入一个整型数据.</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #00688B; font-weight: bold">void</span> cLua::PushInt(<span style="color: #00688B; font-weight: bold">int</span> value) {
    lua_pushinteger(m_pScriptContext, value);
}
</pre></div>


<p><br>
这两个方法都要求传入参数在 Lua 栈中的位置.</p>
<p>好了, 现在我们大概可以写出这个 LuaGlue 的底层代码了:</p>
<div class="codehilite" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>LuaGlue <span style="color: #008b45">LuaGlue_Add</span>(lua_State* L) {
    <span style="color: #00688B; font-weight: bold">int</span> argNum = <span style="color: #B452CD">1</span>;
    <span style="color: #00688B; font-weight: bold">int</span> nSum1 = luaL_optinteger(L, argNum++, <span style="color: #B452CD">0</span>);   <span style="color: #228B22">// 取出参数一</span>
    <span style="color: #00688B; font-weight: bold">int</span> nSum2 = luaL_optinteger(L, argNum++, <span style="color: #B452CD">0</span>);   <span style="color: #228B22">// 取出参数二</span>
    lua_pushinteger(L, nSum1 + nSum2);      <span style="color: #228B22">// 压入结果</span>
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span>;   <span style="color: #228B22">// 表示此 LuaGlue 函数有一个返回值</span>
}
</pre></div>


<p><br>
最后, 需要说明的是 LuaGlue 函数的返回值个数, Lua 函数可以返回多个值, LuaGlue 函数也支持这个特性.<br>
它通过最后一句代码 return x; 来指定到底返回了几个值, 当然这个数值必须要和 Lua 栈中实际 Push 进的返回值数量一致.<br>
另外, 这个函数中还用到一个小技巧, 在函数开始定义了一个局部变量并初始为 1, 每当从 Lua 栈中读取了一个参数就递加 1.</p>
            <div align="center" style="color:#ccc;">☠</div>
        </div>
    </article>
</section>
  </article>


</body>
</html>